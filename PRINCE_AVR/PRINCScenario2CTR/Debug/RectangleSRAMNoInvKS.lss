
AVRASM ver. 2.1.57  K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm Sat Jul 04 17:15:37 2015

[builtin](2): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\tn45def.inc'
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(21): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\tn45def.inc'
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): Including file 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm'
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(10): warning: Use of undefined or forward referenced symbol 'SRAM_PTEXT' in .equ/.set
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(35): warning: Register r30 already defined by the .DEF directive
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(36): warning: Register r31 already defined by the .DEF directive
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(43): warning: Register r26 already defined by the .DEF directive
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(44): warning: Register r27 already defined by the .DEF directive
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(47): warning: .def: 'YL' redefinition (r28->r28)
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(47): warning: Register r28 already defined by the .DEF directive
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(48): warning: .def: 'YH' redefinition (r29->r29)
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(48): warning: Register r29 already defined by the .DEF directive
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(50): warning: .def: 'ZL' redefinition (r30->r30)
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(50): warning: Register r30 already defined by the .DEF directive
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(51): warning: .def: 'ZH' redefinition (r31->r31)
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(51): warning: Register r31 already defined by the .DEF directive
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
                 
                 /*
                 
                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny45.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "tn45def.inc"
                 ;* Title             : Register/Bit Definitions for the ATtiny45
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATtiny45
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _TN45DEF_INC_
                 #define _TN45DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATtiny45
                 #pragma AVRPART ADMIN PART_NAME ATtiny45
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x92
                 .equ	SIGNATURE_002	= 0x06
                 
                 #pragma AVRPART CORE CORE_VERSION V2
                 #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	GIMSK	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	TCCR0B	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	TCCR1	= 0x30
                 .equ	TCNT1	= 0x2f
                 .equ	OCR1A	= 0x2e
                 .equ	OCR1C	= 0x2d
                 .equ	GTCCR	= 0x2c
                 .equ	OCR1B	= 0x2b
                 .equ	TCCR0A	= 0x2a
                 .equ	OCR0A	= 0x29
                 .equ	OCR0B	= 0x28
                 .equ	PLLCSR	= 0x27
                 .equ	CLKPR	= 0x26
                 .equ	DT1A	= 0x25
                 .equ	DT1B	= 0x24
                 .equ	DTPS	= 0x23
                 .equ	DWDR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	PRR	= 0x20
                 .equ	EEARH	= 0x1f
                 .equ	EEARL	= 0x1e
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PCMSK	= 0x15
                 .equ	DIDR0	= 0x14
                 .equ	GPIOR2	= 0x13
                 .equ	GPIOR1	= 0x12
                 .equ	GPIOR0	= 0x11
                 .equ	USIBR	= 0x10
                 .equ	USIDR	= 0x0f
                 .equ	USISR	= 0x0e
                 .equ	USICR	= 0x0d
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCH	= 0x05
                 .equ	ADCL	= 0x04
                 .equ	ADCSRB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** PORTB ************************
                 ; PORTB - Data Register, Port B
                 .equ	PORTB0	= 0	; 
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; 
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; 
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; 
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; 
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; 
                 .equ	PB5	= 5	; For compatibility
                 
                 ; DDRB - Data Direction Register, Port B
                 .equ	DDB0	= 0	; 
                 .equ	DDB1	= 1	; 
                 .equ	DDB2	= 2	; 
                 .equ	DDB3	= 3	; 
                 .equ	DDB4	= 4	; 
                 .equ	DDB5	= 5	; 
                 
                 ; PINB - Input Pins, Port B
                 .equ	PINB0	= 0	; 
                 .equ	PINB1	= 1	; 
                 .equ	PINB2	= 2	; 
                 .equ	PINB3	= 3	; 
                 .equ	PINB4	= 4	; 
                 .equ	PINB5	= 5	; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	AINBG	= ACBG	; For compatibility
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR0 - 
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	REFS2	= 4	; Reference Selection Bit 2
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                 .equ	IPR	= 5	; Input Polarity Mode
                 .equ	BIN	= 7	; Bipolar Input Mode
                 
                 ; DIDR0 - Digital Input Disable Register 0
                 .equ	ADC1D	= 2	; ADC1 Digital input Disable
                 .equ	ADC3D	= 3	; ADC3 Digital input Disable
                 .equ	ADC2D	= 4	; ADC2 Digital input Disable
                 .equ	ADC0D	= 5	; ADC0 Digital input Disable
                 
                 
                 ; ***** USI **************************
                 ; USIBR - USI Buffer Register
                 .equ	USIBR0	= 0	; USI Buffer Register bit 0
                 .equ	USIBR1	= 1	; USI Buffer Register bit 1
                 .equ	USIBR2	= 2	; USI Buffer Register bit 2
                 .equ	USIBR3	= 3	; USI Buffer Register bit 3
                 .equ	USIBR4	= 4	; USI Buffer Register bit 4
                 .equ	USIBR5	= 5	; USI Buffer Register bit 5
                 .equ	USIBR6	= 6	; USI Buffer Register bit 6
                 .equ	USIBR7	= 7	; USI Buffer Register bit 7
                 
                 ; USIDR - USI Data Register
                 .equ	USIDR0	= 0	; USI Data Register bit 0
                 .equ	USIDR1	= 1	; USI Data Register bit 1
                 .equ	USIDR2	= 2	; USI Data Register bit 2
                 .equ	USIDR3	= 3	; USI Data Register bit 3
                 .equ	USIDR4	= 4	; USI Data Register bit 4
                 .equ	USIDR5	= 5	; USI Data Register bit 5
                 .equ	USIDR6	= 6	; USI Data Register bit 6
                 .equ	USIDR7	= 7	; USI Data Register bit 7
                 
                 ; USISR - USI Status Register
                 .equ	USICNT0	= 0	; USI Counter Value Bit 0
                 .equ	USICNT1	= 1	; USI Counter Value Bit 1
                 .equ	USICNT2	= 2	; USI Counter Value Bit 2
                 .equ	USICNT3	= 3	; USI Counter Value Bit 3
                 .equ	USIDC	= 4	; Data Output Collision
                 .equ	USIPF	= 5	; Stop Condition Flag
                 .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
                 .equ	USISIF	= 7	; Start Condition Interrupt Flag
                 
                 ; USICR - USI Control Register
                 .equ	USITC	= 0	; Toggle Clock Port Pin
                 .equ	USICLK	= 1	; Clock Strobe
                 .equ	USICS0	= 2	; USI Clock Source Select Bit 0
                 .equ	USICS1	= 3	; USI Clock Source Select Bit 1
                 .equ	USIWM0	= 4	; USI Wire Mode Bit 0
                 .equ	USIWM1	= 5	; USI Wire Mode Bit 1
                 .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
                 .equ	USISIE	= 7	; Start Condition Interrupt Enable
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; MCUCR - MCU Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 
                 ; GIMSK - General Interrupt Mask Register
                 .equ	GICR	= GIMSK	; For compatibility
                 .equ	PCIE	= 5	; Pin Change Interrupt Enable
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 
                 ; GIFR - General Interrupt Flag register
                 .equ	PCIF	= 5	; Pin Change Interrupt Flag
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 
                 ; PCMSK - Pin Change Enable Mask
                 .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 0
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0B	= 3	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 .equ	OCIE0A	= 4	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 
                 ; TIFR - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                 .equ	OCF0B	= 3	; Timer/Counter0 Output Compare Flag 0B
                 .equ	OCF0A	= 4	; Timer/Counter0 Output Compare Flag 0A
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCR0_0	= 0	; 
                 .equ	OCR0_1	= 1	; 
                 .equ	OCR0_2	= 2	; 
                 .equ	OCR0_3	= 3	; 
                 .equ	OCR0_4	= 4	; 
                 .equ	OCR0_5	= 5	; 
                 .equ	OCR0_6	= 6	; 
                 .equ	OCR0_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 ;.equ	OCR0_0	= 0	; 
                 ;.equ	OCR0_1	= 1	; 
                 ;.equ	OCR0_2	= 2	; 
                 ;.equ	OCR0_3	= 3	; 
                 ;.equ	OCR0_4	= 4	; 
                 ;.equ	OCR0_5	= 5	; 
                 ;.equ	OCR0_6	= 6	; 
                 ;.equ	OCR0_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSR0	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TCCR1 - Timer/Counter Control Register
                 .equ	CS10	= 0	; Clock Select Bits
                 .equ	CS11	= 1	; Clock Select Bits
                 .equ	CS12	= 2	; Clock Select Bits
                 .equ	CS13	= 3	; Clock Select Bits
                 .equ	COM1A0	= 4	; Compare Output Mode, Bit 1
                 .equ	COM1A1	= 5	; Compare Output Mode, Bit 0
                 .equ	PWM1A	= 6	; Pulse Width Modulator Enable
                 .equ	CTC1	= 7	; Clear Timer/Counter on Compare Match
                 
                 ; TCNT1 - Timer/Counter Register
                 .equ	TCNT1_0	= 0	; Timer/Counter Register Bit 0
                 .equ	TCNT1_1	= 1	; Timer/Counter Register Bit 1
                 .equ	TCNT1_2	= 2	; Timer/Counter Register Bit 2
                 .equ	TCNT1_3	= 3	; Timer/Counter Register Bit 3
                 .equ	TCNT1_4	= 4	; Timer/Counter Register Bit 4
                 .equ	TCNT1_5	= 5	; Timer/Counter Register Bit 5
                 .equ	TCNT1_6	= 6	; Timer/Counter Register Bit 6
                 .equ	TCNT1_7	= 7	; Timer/Counter Register Bit 7
                 
                 ; OCR1A - Output Compare Register
                 .equ	OCR1A0	= 0	; Output Compare Register A Bit 0
                 .equ	OCR1A1	= 1	; Output Compare Register A Bit 1
                 .equ	OCR1A2	= 2	; Output Compare Register A Bit 2
                 .equ	OCR1A3	= 3	; Output Compare Register A Bit 3
                 .equ	OCR1A4	= 4	; Output Compare Register A Bit 4
                 .equ	OCR1A5	= 5	; Output Compare Register A Bit 5
                 .equ	OCR1A6	= 6	; Output Compare Register A Bit 6
                 .equ	OCR1A7	= 7	; Output Compare Register A Bit 7
                 
                 ; OCR1B - Output Compare Register
                 .equ	OCR1B0	= 0	; Output Compare Register B Bit 0
                 .equ	OCR1B1	= 1	; Output Compare Register B Bit 1
                 .equ	OCR1B2	= 2	; Output Compare Register B Bit 2
                 .equ	OCR1B3	= 3	; Output Compare Register B Bit 3
                 .equ	OCR1B4	= 4	; Output Compare Register B Bit 4
                 .equ	OCR1B5	= 5	; Output Compare Register B Bit 5
                 .equ	OCR1B6	= 6	; Output Compare Register B Bit 6
                 .equ	OCR1B7	= 7	; Output Compare Register B Bit 7
                 
                 ; OCR1C - Output compare register
                 .equ	OCR1C0	= 0	; 
                 .equ	OCR1C1	= 1	; 
                 .equ	OCR1C2	= 2	; 
                 .equ	OCR1C3	= 3	; 
                 .equ	OCR1C4	= 4	; 
                 .equ	OCR1C5	= 5	; 
                 .equ	OCR1C6	= 6	; 
                 .equ	OCR1C7	= 7	; 
                 
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 5	; OCIE1A: Timer/Counter1 Output Compare B Interrupt Enable
                 .equ	OCIE1A	= 6	; OCIE1A: Timer/Counter1 Output Compare Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 5	; Timer/Counter1 Output Compare Flag 1B
                 .equ	OCF1A	= 6	; Timer/Counter1 Output Compare Flag 1A
                 
                 ; GTCCR - Timer counter control register
                 .equ	PSR1	= 1	; Prescaler Reset Timer/Counter1
                 .equ	FOC1A	= 2	; Force Output Compare 1A
                 .equ	FOC1B	= 3	; Force Output Compare Match 1B
                 .equ	COM1B0	= 4	; Comparator B Output Mode
                 .equ	COM1B1	= 5	; Comparator B Output Mode
                 .equ	PWM1B	= 6	; Pulse Width Modulator B Enable
                 
                 ; DTPS - Dead time prescaler register
                 .equ	DTPS0	= 0	; 
                 .equ	DTPS1	= 1	; 
                 
                 ; DT1A - Dead time value register
                 .equ	DTVL0	= 0	; 
                 .equ	DTVL1	= 1	; 
                 .equ	DTVL2	= 2	; 
                 .equ	DTVL3	= 3	; 
                 .equ	DTVH0	= 4	; 
                 .equ	DTVH1	= 5	; 
                 .equ	DTVH2	= 6	; 
                 .equ	DTVH3	= 7	; 
                 
                 ; DT1B - Dead time value B
                 ;.equ	DTVL0	= 0	; 
                 ;.equ	DTVL1	= 1	; 
                 ;.equ	DTVL2	= 2	; 
                 ;.equ	DTVL3	= 3	; 
                 ;.equ	DTVH0	= 4	; 
                 ;.equ	DTVH1	= 5	; 
                 ;.equ	DTVH2	= 6	; 
                 ;.equ	DTVH3	= 7	; 
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                 .equ	BODSE	= 2	; BOD Sleep Enable
                 .equ	SM0	= 3	; Sleep Mode Select Bit 0
                 .equ	SM1	= 4	; Sleep Mode Select Bit 1
                 .equ	SE	= 5	; Sleep Enable
                 .equ	PUD	= 6	; Pull-up Disable
                 .equ	BODS	= 7	; BOD Sleep
                 
                 ; MCUSR - MCU Status register
                 .equ	PORF	= 0	; Power-On Reset Flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSI	= 1	; Power Reduction USI
                 .equ	PRTIM0	= 2	; Power Reduction Timer/Counter0
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 
                 ; OSCCAL - Oscillator Calibration Register
                 .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
                 .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
                 .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
                 .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
                 .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
                 .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
                 .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
                 .equ	CAL7	= 7	; Oscillatro Calibration Value Bit 7
                 
                 ; PLLCSR - PLL Control and status register
                 .equ	PLOCK	= 0	; PLL Lock detector
                 .equ	PLLE	= 1	; PLL Enable
                 .equ	PCKE	= 2	; PCK Enable
                 .equ	LSM	= 7	; Low speed mode
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; DWDR - debugWire data register
                 .equ	DWDR0	= 0	; 
                 .equ	DWDR1	= 1	; 
                 .equ	DWDR2	= 2	; 
                 .equ	DWDR3	= 3	; 
                 .equ	DWDR4	= 4	; 
                 .equ	DWDR5	= 5	; 
                 .equ	DWDR6	= 6	; 
                 .equ	DWDR7	= 7	; 
                 
                 ; GPIOR2 - General Purpose IO register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General purpose register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCSR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	RFLB	= 3	; Read fuse and lock bits
                 .equ	CTPB	= 4	; Clear temporary page buffer
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lockbit
                 .equ	LB2	= 1	; Lockbit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock source
                 .equ	CKSEL1	= 1	; Select Clock source
                 .equ	CKSEL2	= 2	; Select Clock source
                 .equ	CKSEL3	= 3	; Select Clock source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock Output Enable
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through the Chip Erase
                 .equ	WDTON	= 4	; Watchdog Timer always on
                 .equ	SPIEN	= 5	; Enable Serial Program and Data Downloading
                 .equ	DWEN	= 6	; DebugWIRE Enable
                 .equ	RSTDISBL	= 7	; External Reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	SELFPRGEN	= 0	; Self-Programming Enable
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x07ff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 256
                 .equ	RAMEND	= 0x015f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x00ff
                 .equ	EEPROMEND	= 0x00ff
                 .equ	EEADRBITS	= 8
                 #pragma AVRPART MEMORY PROG_FLASH 4096
                 #pragma AVRPART MEMORY EEPROM 256
                 #pragma AVRPART MEMORY INT_SRAM SIZE 256
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x0
                 .equ	NRWW_STOP_ADDR	= 0x7ff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x0
                 .equ	PAGESIZE	= 32
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt 0
                 .equ	PCI0addr	= 0x0002	; Pin change Interrupt Request 0
                 .equ	OC1Aaddr	= 0x0003	; Timer/Counter1 Compare Match 1A
                 .equ	OVF1addr	= 0x0004	; Timer/Counter1 Overflow
                 .equ	OVF0addr	= 0x0005	; Timer/Counter0 Overflow
                 .equ	ERDYaddr	= 0x0006	; EEPROM Ready
                 .equ	ACIaddr	= 0x0007	; Analog comparator
                 .equ	ADCCaddr	= 0x0008	; ADC Conversion ready
                 .equ	OC1Baddr	= 0x0009	; Timer/Counter1 Compare Match B
                 .equ	OC0Aaddr	= 0x000a	; Timer/Counter0 Compare Match A
                 .equ	OC0Baddr	= 0x000b	; Timer/Counter0 Compare Match B
                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out
                 .equ	USI_STARTaddr	= 0x000d	; USI START
                 .equ	USI_OVFaddr	= 0x000e	; USI Overflow
                 
                 .equ	INT_VECTORS_SIZE	= 15	; size in words
                 
                 #endif  /* _TN45DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                  * interface.asm
                  *
                  *  Created: 2015/4/23 23:35:49
                  *   Author: nevermore
                  */ 
                 
                 
                  /*
                  * interface.asm
                  *
                  *  Created: 2015/4/22 11:35:06
                  *   Author: Zheng Gong
                  */ 
                  ; encrypt_main_tiny45 : generates the plain text and key internally,
                 ; sends a trigger, encrypts and sends a second trigger
                 ; based on http://point-at-infinity.org/avraes/rijndaelfurious.asm.html
                 
                 ; modify the interface by humuchuang because the label "SRAM_DATA" cannot be recognized by the file KLEIN.asm
                 
                 .include "tn45def.inc"
                 
                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny45.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "tn45def.inc"
                 ;* Title             : Register/Bit Definitions for the ATtiny45
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATtiny45
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _TN45DEF_INC_
                 #endif  /* _TN45DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 ; Define the cipher to include here (#define <cipher>)
                 #define	rectangle;(currently works for aes, desxl, hight, idea, kasumi, katan, klein, mcrypton, noekeon, present, sea, tea)
                 
                 
                 .ORG 0x0000
                 ; global interrupt disable
000000 94f8      	cli
                 ; initialize stack
000001 e0f1      	ldi		r31,HIGH(RAMEND)
000002 bffe      	out		SPH,r31
000003 e5ff      	ldi		r31,LOW(RAMEND)
000004 bffd      	out		SPL,r31
                 
                 ; initialize trigger B1
000005 e003        	ldi		r16, 0b11	; portB,1 = output (triggers)
000006 bb07        	out		DDRB, r16
                 
000007 c160      	rjmp	main
                 
                 
                 ;******************* INCLUDE FILES *******************************
                 ; include encryption algorithm
                 #ifdef	aes
                 #elif aesfurious
                 #elif rectangle
                     .include "Rectangle80SRAM.asm";"./Rectangle128OnTheFly.asm";"Rectangle80.asm"
                 
                 ; Constants
                 ;
                 .EQU    PTEXT_NUM_BYTE = 8
                 .EQU    CTEXT_NUM_BYTE = 8
                 .EQU    KEY_NUM_BYTE = 10
                 .EQU	KEYEXTENT_NUM_BYTE = 208;26*8
                 .EQU	ADD_MEM_NUM_BYTE = 0 ;Additional memory for internal computation
                 .EQU	TOT_NUM_BYTE = PTEXT_NUM_BYTE+KEY_NUM_BYTE+ADD_MEM_NUM_BYTE+KEYEXTENT_NUM_BYTE
                 .EQU    SRAM_CTEXT = SRAM_PTEXT
                 
                 ; Registers declarations
                 .def s0 =r0
                 .def s1 =r1
                 .def s2 =r2
                 .def s3 =r3
                 .def s4 =r4
                 .def s5 =r5
                 .def s6 =r6
                 .def s7 =r7
                 
                 .def k0 =r16
                 .def k1 =r17
                 .def k2 =r18
                 .def k3 =r19
                 .def k4 =r20
                 .def k5 =r21
                 .def k6 =r22
                 .def k7 =r23
                 .def k8 =r8
                 .def k9 =r9
                 
                 .def t0 =r24
                 .def t1 =r25
                 .def t2 =r30
                 .def t3 =r31
                 
                 .def g0 =r12
                 .def g1 =r13
                 .def g2 =r14
                 .def g3 =r15
                 
                 .def rrn   =r26
                 .def rcnt  =r27
                 .def rzero =r10
                 
                 .def YL =r28
                 .def YH =r29
                 
                 .def ZL =r30
                 .def ZH =r31
                 
                 ;*****************************************************************************
                 ;;; load_key
                 ;;; 
                 ;;; load master key to:
                 ;;; r3:r2:r1:r0
                 ;;; r7:r6:r5:r4
                 ;;; r11:r10:r9:r8
                 ;;; r15:r14:r13:r12
                 
                 .MACRO load_key
                     ld   k0, Y+					; 1 ins, 2 clocks
                     ld   k1, Y+					; 1 ins, 2 clocks
                     ld   k2, Y+					; 1 ins, 2 clocks
                     ld   k3, Y+					; 1 ins, 2 clocks
                     ld   k4, Y+					; 1 ins, 2 clocks
                     ld   k5, Y+					; 1 ins, 2 clocks
                     ld   k6, Y+					; 1 ins, 2 clocks
                     ld   k7, Y+					; 1 ins, 2 clocks
                     ld   k8, Y+					; 1 ins, 2 clocks
                     ld   k9, Y+					; 1 ins, 2 clocks
                 .ENDMACRO
                 
                 ;;;****************************************************************************
                 ;;;
                 ;;; store_subkey
                 ;;; 
                 .MACRO store_subkey
                 	st  Y+, k0	
                 	st  Y+, k1	
                 	st  Y+, k2	
                 	st  Y+, k3	
                 	st  Y+, k4	
                 	st  Y+, k5	
                 	st  Y+, k6
                 	st  Y+, k7
                 .ENDMACRO
                 
                 
                 ;;;****************************************************************************
                 ;;;
                 ;;; load_input
                 ;;;
                 .MACRO load_input
                 	ld  s0, Y+
                 	ld  s1, Y+
                 	ld  s2, Y+
                 	ld  s3, Y+
                 	ld  s4, Y+
                 	ld  s5, Y+
                 	ld  s6, Y+
                 	ld  s7, Y
                 .ENDMACRO
                 
                 ;;;****************************************************************************
                 ;;;
                 ;;; store_output
                 ;;; 
                 .MACRO store_output
                 	st  Y+, s0
                 	st  Y+, s1
                 	st  Y+, s2
                 	st  Y+, s3
                 	st  Y+, s4
                 	st  Y+, s5
                 	st  Y+, s6
                 	st  Y , s7
                 .ENDMACRO
                 
                 ;;;****************************************************************************
                 ;;;
                 ;;; add_round_key
                 
                 .MACRO forward_key_update
                 	;forward_key_sbox:
                 	mov  t0, k0
                 	mov  t1, k2
                 	mov  t2, k4
                 	mov  t3, k6
                 
                 	andi k0, 0xf0
                 	andi k2, 0xf0
                 	andi k4, 0xf0
                 	andi k6, 0xf0
                 
                 	mov  g0, t2
                 	eor  t2, t1
                 	com  t1
                 	mov  g1, t0
                 	and  t0, t1
                 	or   t1, t3
                 	eor  t1, g1
                 	eor  t3, g0
                 	eor  t0, t3
                 	and  t3, t1
                 	eor  t3, t2
                 	or   t2, t0
                 	eor  t2, t1
                 	eor  t1, g0
                 
                 	andi t0, 0x0f
                 	andi t1, 0x0f
                 	andi t2, 0x0f
                 	andi t3, 0x0f
                 
                 	or   k0, t0
                 	or   k2, t1
                 	or   k4, t2
                 	or   k6, t3
                 
                 	movw g0, k6
                 	movw k6, k8
                 	movw k8, k0
                 	movw k0, k2
                 	movw k2, k4
                 	movw k4, g0
                 	eor  k0, k9
                 	eor  k1, k8
                 
                 	swap g0
                 	swap g1
                 	movw t0, g0
                 	eor  t1, t0
                 	andi t1, 0xf0
                 	eor  g0, t1
                 	eor  g1, t1
                 	
                 	eor  k6, g0
                 	eor  k7, g1
                 
                 	;key_addRC
                     ldi ZH, high(RC<<1)			; 1 ins, 1 clock
                     ldi ZL, low(RC<<1)			; 1 ins, 1 clock
                     add ZL, rcnt				; 1 ins, 1 clock
                     lpm t0, Z				; 1 ins, 3 clocks
                     eor k8, t0				; 1 ins, 1 clock
                 	inc rcnt
                 .ENDMACRO
                 
                 
                 ;;;****************************************************************************
                 .MACRO keyxor
                 	ld  k0, Y+
                 	ld  k1, Y+
                 	ld  k2, Y+
                 	ld  k3, Y+
                 	ld  k4, Y+
                 	ld  k5, Y+
                 	ld  k6, Y+
                 	ld  k7, Y+
                     eor s0, k0
                     eor s1, k1
                     eor s2, k2
                     eor s3, k3
                     eor s4, k4
                     eor s5, k5
                     eor s6, k6
                     eor s7, k7
                 .ENDMACRO
                 
                 ;;;****************************************************************************
                 .MACRO ikeyxor
                 	ld  k7, -Y
                 	ld  k6, -Y
                 	ld  k5, -Y
                 	ld  k4, -Y
                 	ld  k3, -Y
                 	ld  k2, -Y
                 	ld  k1, -Y
                 	ld  k0, -Y
                     eor s0, k0
                     eor s1, k1
                     eor s2, k2
                     eor s3, k3
                     eor s4, k4
                     eor s5, k5
                     eor s6, k6
                     eor s7, k7
                 .ENDMACRO
                 
                 .MACRO forward_round
                     keyxor
                 
                     ;forward_sbox
                 	movw t0, s4
                 
                 	eor  s4, s2
                 	eor  s5, s3
                 
                 	com  s2
                 	com  s3
                 
                 	movw t2, s0
                 
                 	and  s0, s2
                 	and  s1, s3
                 
                 	or   s2, s6
                 	or   s3, s7
                 
                 	eor  s6, t0
                 	eor  s7, t1
                 
                 	eor  s0, s6
                 	eor  s1, s7
                 
                 	eor  s2, t2
                 	eor  s3, t3
                 
                 	and  s6, s2
                 	and  s7, s3
                 
                 	eor  s6, s4
                 	eor  s7, s5
                 
                 	or   s4, s0
                 	or   s5, s1
                 
                 	eor  s4, s2
                 	eor  s5, s3
                 
                 	eor  s2, t0
                 	eor  s3, t1
                 
                     ;forward_permutation
                     ;rotate16_left_row1 <<< 1
                 	lsl s2     
                     rol s3     
                     adc s2, rzero 
                 	
                 	;rotate16_left_row2 <<< 12 = >>> 4
                 	swap s4
                 	swap s5
                 	movw t0, s4
                 	eor  t1, t0
                 	andi t1, 0xf0
                 	eor  s4, t1
                 	eor  s5, t1
                 	
                 	;rotate16_left_row3 <<< 13 = >>> 3 = ((>>>4)<<<1)
                 	swap s6
                 	swap s7
                 	movw t0, s6
                 	eor  t1, t0
                 	andi t1, 0xf0
                 	eor  s6, t1
                 	eor  s7, t1
                 
                 	lsl  s6     
                     rol  s7     
                     adc  s6, rzero 
                 
                 	inc rcnt
                 .ENDMACRO
                 
                 .MACRO forward_last_round
                     keyxor
                 .ENDMACRO
                 
                 .MACRO invert_round
                 	dec rcnt
                 	ikeyxor
                 
                     ;invert_permutation
                 	;rotate16_right_row1 >>> 1
                 	bst s2, 0
                     ror s3   
                     ror s2    
                     bld s3, 7
                 
                 	;rotate16_right_row2 >>> 12 = <<< 4
                 	swap s4
                 	swap s5
                 	movw t0, s4
                 	eor  t1, t0
                 	andi t1, 0x0f
                 	eor  s4, t1
                 	eor  s5, t1
                 
                 	;rotate16_right_row3 >>> 13 = <<< 3
                 	lsl s6     
                     rol s7     
                     adc s6, rzero 
                 	lsl s6     
                     rol s7     
                     adc s6, rzero 
                 	lsl s6     
                     rol s7     
                     adc s6, rzero 
                 
                     ;invert_sbox
                 	movw  t0, s0
                 
                 	and   s0, s4
                 	and   s1, s5
                 
                 	eor   s0, s6
                 	eor   s1, s7
                 
                 	or    s6, t0
                 	or    s7, t1
                 
                 	eor   s6, s4
                 	eor   s7, s5
                 
                 	eor   s2, s6
                 	eor   s3, s7
                 
                 	movw  s4, s2
                 
                 	eor   s2, t0
                 	eor   s3, t1
                 
                 	eor   s2, s0
                 	eor   s3, s1
                 
                 	com   s6
                 	com   s7
                 
                 	movw  t0, s6
                 
                 	or    s6, s2
                 	or    s7, s3
                 
                 	eor   s6, s0
                 	eor   s7, s1
                 
                 	and   s0, s2
                 	and   s1, s3
                 
                 	eor   s0, t0
                 	eor   s1, t1
                 .ENDMACRO
                 
                 .MACRO invert_last_round
                     ikeyxor
                 .ENDMACRO
                 
                 
                 encrypt:
000008 e1a9      	ldi rrn, 25
000009 24aa          clr rzero
00000a e0d0          ldi YH, high(SRAM_PTEXT)
00000b e6c0          ldi YL, low(SRAM_PTEXT)
00000c 9009
00000d 9019
00000e 9029
00000f 9039
000010 9049
000011 9059
000012 9069
000013 8078          load_input
000014 e0d0      	ldi YH, high(SRAM_SUBKEY)
000015 e7c2          ldi YL, low(SRAM_SUBKEY)
000016 27bb      	clr rcnt
                 encrypt_start:
000017 9109
000018 9119
000019 9129
00001a 9139
00001b 9149
00001c 9159
00001d 9169
00001e 9179
00001f 2600
000020 2611
000021 2622
000022 2633
000023 2644
000024 2655
000025 2666
000026 2677
000027 01c2
000028 2442
000029 2453
00002a 9420
00002b 9430
00002c 01f0
00002d 2002
00002e 2013
00002f 2826
000030 2837
000031 2668
000032 2679
000033 2406
000034 2417
000035 262e
000036 263f
000037 2062
000038 2073
000039 2464
00003a 2475
00003b 2840
00003c 2851
00003d 2442
00003e 2453
00003f 2628
000040 2639
000041 0c22
000042 1c33
000043 1c2a
000044 9442
000045 9452
000046 01c2
000047 2798
000048 7f90
000049 2649
00004a 2659
00004b 9462
00004c 9472
00004d 01c3
00004e 2798
00004f 7f90
000050 2669
000051 2679
000052 0c66
000053 1c77
000054 1c6a
000055 95b3          forward_round
000056 13ba      	cpse rcnt, rrn
000057 cfbf      	rjmp encrypt_start
000058 9109
000059 9119
00005a 9129
00005b 9139
00005c 9149
00005d 9159
00005e 9169
00005f 9179
000060 2600
000061 2611
000062 2622
000063 2633
000064 2644
000065 2655
000066 2666
000067 2677          forward_last_round
000068 e0d0          ldi YH, high(SRAM_PTEXT)
000069 e6c0          ldi YL, low(SRAM_PTEXT)
00006a 9209
00006b 9219
00006c 9229
00006d 9239
00006e 9249
00006f 9259
000070 9269
000071 8278          store_output
000072 9508      ret
                 
                 keyschedule:
000073 e1a9      	ldi rrn, 25
000074 24aa      	clr rzero
000075 e0d0          ldi YH, high(SRAM_KEY)
000076 e6c8          ldi YL, low(SRAM_KEY)
000077 9109
000078 9119
000079 9129
00007a 9139
00007b 9149
00007c 9159
00007d 9169
00007e 9179
00007f 9089
000080 9099          load_key
000081 e0d0      	ldi YH, high(SRAM_SUBKEY)
000082 e7c2          ldi YL, low(SRAM_SUBKEY)
000083 9309
000084 9319
000085 9329
000086 9339
000087 9349
000088 9359
000089 9369
00008a 9379      	store_subkey
00008b 27bb      	clr rcnt
                 keyschedule_start:
00008c 2f80
00008d 2f92
00008e 2fe4
00008f 2ff6
000090 7f00
000091 7f20
000092 7f40
000093 7f60
000094 2ece
000095 27e9
000096 9590
000097 2ed8
000098 2389
000099 2b9f
00009a 259d
00009b 25fc
00009c 278f
00009d 23f9
00009e 27fe
00009f 2be8
0000a0 27e9
0000a1 259c
0000a2 708f
0000a3 709f
0000a4 70ef
0000a5 70ff
0000a6 2b08
0000a7 2b29
0000a8 2b4e
0000a9 2b6f
0000aa 016b
0000ab 01b4
0000ac 0148
0000ad 0189
0000ae 019a
0000af 01a6
0000b0 2509
0000b1 2518
0000b2 94c2
0000b3 94d2
0000b4 01c6
0000b5 2798
0000b6 7f90
0000b7 26c9
0000b8 26d9
0000b9 256c
0000ba 257d
0000bb e0f2
0000bc e9e0
0000bd 0feb
0000be 9184
0000bf 2688
0000c0 95b3          forward_key_update
0000c1 9309
0000c2 9319
0000c3 9329
0000c4 9339
0000c5 9349
0000c6 9359
0000c7 9369
0000c8 9379      	store_subkey
0000c9 13ba      	cpse rcnt, rrn
0000ca cfc1      	rjmp keyschedule_start
                 keyschedule_last:
0000cb 9508      ret
                 
                 decrypt:
0000cc 27aa      	clr rrn
0000cd 24aa          clr rzero
0000ce e0d0          ldi YH, high(SRAM_PTEXT)
0000cf e6c0          ldi YL, low(SRAM_PTEXT)
0000d0 9009
0000d1 9019
0000d2 9029
0000d3 9039
0000d4 9049
0000d5 9059
0000d6 9069
0000d7 8078          load_input
0000d8 e0d1      	ldi YH, high(SRAM_SUBKEY+KEYEXTENT_NUM_BYTE)
0000d9 e4c2          ldi YL, low(SRAM_SUBKEY+KEYEXTENT_NUM_BYTE)
0000da e1b9      	ldi rcnt, 25
                 decrypt_start:
0000db 95ba
0000dc 917a
0000dd 916a
0000de 915a
0000df 914a
0000e0 913a
0000e1 912a
0000e2 911a
0000e3 910a
0000e4 2600
0000e5 2611
0000e6 2622
0000e7 2633
0000e8 2644
0000e9 2655
0000ea 2666
0000eb 2677
0000ec fa20
0000ed 9437
0000ee 9427
0000ef f837
0000f0 9442
0000f1 9452
0000f2 01c2
0000f3 2798
0000f4 709f
0000f5 2649
0000f6 2659
0000f7 0c66
0000f8 1c77
0000f9 1c6a
0000fa 0c66
0000fb 1c77
0000fc 1c6a
0000fd 0c66
0000fe 1c77
0000ff 1c6a
000100 01c0
000101 2004
000102 2015
000103 2406
000104 2417
000105 2a68
000106 2a79
000107 2464
000108 2475
000109 2426
00010a 2437
00010b 0121
00010c 2628
00010d 2639
00010e 2420
00010f 2431
000110 9460
000111 9470
000112 01c3
000113 2862
000114 2873
000115 2460
000116 2471
000117 2002
000118 2013
000119 2608
00011a 2619          invert_round
00011b 13ba      	cpse rcnt, rrn
00011c cfbe      	rjmp decrypt_start
00011d 917a
00011e 916a
00011f 915a
000120 914a
000121 913a
000122 912a
000123 911a
000124 910a
000125 2600
000126 2611
000127 2622
000128 2633
000129 2644
00012a 2655
00012b 2666
00012c 2677          invert_last_round
00012d e0d0          ldi YH, high(SRAM_PTEXT)
00012e e6c0          ldi YL, low(SRAM_PTEXT)
00012f 9209
000130 9219
000131 9229
000132 9239
000133 9249
000134 9259
000135 9269
000136 8278          store_output
000137 9508      ret
                 
                 Sbox:
000138 0506
000139 0a0c
00013a 0e01
00013b 0907
00013c 000b
00013d 0d03
00013e 0f08
00013f 0204      .DB 0x6, 0x5, 0xc, 0xa, 0x1, 0xe, 0x7, 0x9, 0xb, 0x0, 0x3, 0xd, 0x8, 0xf, 0x4, 0x2
                 
                 ISbox:
000140 0409
000141 0a0f
000142 010e
000143 0600
000144 070c
000145 0803
000146 0b02
000147 0d05      .DB 0x9, 0x4, 0xf, 0xa, 0xe, 0x1, 0x0, 0x6, 0xc, 0x7, 0x3, 0x8, 0x2, 0xb, 0x5, 0xd
                 
                 RC:
000148 0201
000149 0904
00014a 0512
00014b 160b
00014c 190c
00014d 0713
00014e 1f0f
00014f 1c1e
000150 1118
000151 0603
000152 1b0d
000153 0e17
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm(454): warning: .cseg .db misalignment - padding zero byte
K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\interface.asm(50): 'K:\Seagate\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR_NewKS_SRA\RectangleSRAMNoInvKS\Rectangle80SRAM.asm' included form here
000154 001d      .DB 0x01, 0x02, 0x04, 0x09, 0x12, 0x05, 0x0b, 0x16, 0x0c, 0x19, 0x13, 0x07, 0x0f, 0x1f, 0x1e, 0x1c, 0x18, 0x11, 0x03, 0x06, 0x0d, 0x1b, 0x17, 0x0e, 0x1d 
                 
                 #elif desxl
                 #elif hight
                 #elif idea
                 #elif kasumi
                 #elif katan
                 #elif klein
                 #elif mcrypton
                 #elif noekeon
                 #elif present
                 #elif sea
                 #elif tea
                 #else
                 #endif
                 
                 
                 .CSEG
                 
                 ;******************** FUNCTIONS ***********************************
                 ; This function copy bytes from ROM location pointed by ZH:ZL to
                 ; SRAM location pointed by XH:XL
                 ;	Z must contain source address
                 ;	X must contain destination address
                 ;	r18 must contain the number of byte to copy
                 ;	r16 is used for internal computation
                 copy_word:
000155 9105      	lpm		r16, Z+
000156 930d      	st 		X+,r16
000157 952a      	dec		r18
000158 f7e1      	brbc	1, copy_word
000159 9508      	ret
                 ;*******************************************************************
                 
                 ;******************** Q ELEC FUNCTIONS (START) *********************
                 ; wait : ret + 0xFF * (5*nop + 1*dec + 1*brbc)
                 wait:
00015a ef0f      	ldi		r16, 0xFF	;r16=FF
                 w_loop:
00015b 0000      	nop
00015c 0000      	nop
00015d 0000      	nop
00015e 0000      	nop
00015f 0000      	nop
000160 950a      	dec		r16			; r16=r16-1
000161 f7c9      	brbc	1,w_loop	; branch sur loop si Z=0, cs si r16 != 0
000162 9508      	ret					; return from subroutine
                 
                 
                 
                 ; wait2 : r17 * wait (to be set inside) + some instructions
                 wait2:
000163 ef1f      	ldi		r17, 0xFF	;
                 w_loop2:
000164 dff5      	rcall	wait
000165 951a      	dec		r17			; r17=r17-1
000166 f7e9      	brbc	1,w_loop2	; branch sur loop2 si Z=0, cs si r17 != 0
000167 9508      	ret					; return from subroutine
                 ;******************** Q ELEC FUNCTIONS (END) *********************
                 
                 
                 ;******************** MAIN (START) *******************************
                 main:
                 	;LOAD THE PTEXT FROM THE DB BELOW TO SRAM
000168 e0f3      	ldi		ZH, high(text<<1)
000169 e6e0      	ldi		ZL, low(text<<1)
00016a e0b0      	ldi 	XH, high(SRAM_PTEXT)
00016b e6a0      	ldi 	XL, low(SRAM_PTEXT)
00016c e028      	ldi		r18, PTEXT_NUM_BYTE
00016d dfe7      	rcall	copy_word
                 
                 main_loop:
                 
                 	;LOAD THE KEY FROM THE DB BELOW TO SRAM
00016e e0f3      	ldi		ZH, high(key<<1)
00016f e6e8      	ldi		ZL, low(key<<1)
000170 e0b0      	ldi 	XH, high(SRAM_KEY)
000171 e6a8      	ldi 	XL, low(SRAM_KEY)
000172 e02a      	ldi		r18, KEY_NUM_BYTE
000173 dfe1      	rcall	copy_word
                 
                 
                 	; Initialize XH:XL with start address of ptext/key memory location
000174 e0b0      	ldi 	XH, high(SRAM_PTEXT)
000175 e6a0      	ldi 	XL, low(SRAM_PTEXT)
000176 9ac1      	sbi		PORTB,1		; portA,0 = high (trigger on port A0)
000177 0000      	nop
000178 0000      	nop
000179 0000      	nop
00017a 0000      	nop
00017b 98c1       	cbi		PORTB,1		; portA,0 = low
                 
00017c 0000      	nop
00017d 0000      	nop
00017e 0000      	nop
00017f 0000      	nop
000180 0000      	nop
000181 0000      	nop
000182 0000      	nop
000183 0000      	nop
000184 0000      	nop
000185 0000      	nop
                 
000186 deec      	rcall keyschedule 
                 	
000187 0000      	nop
000188 0000      	nop
000189 0000      	nop
00018a 0000      	nop
00018b 0000      	nop
00018c 0000      	nop
00018d 0000      	nop
00018e 0000      	nop
00018f 0000      	nop
000190 0000      	nop
                 	
000191 de76      	rcall	encrypt		; encryption routine
                 	
                 	;LOAD THE KEY FROM THE DB BELOW TO SRAM
                 	;ldi		ZH, high(key<<1)
                 	;ldi		ZL, low(key<<1)
                 	;ldi 	XH, high(SRAM_KEY)
                 	;ldi 	XL, low(SRAM_KEY)
                 	;ldi		r18, KEY_NUM_BYTE
                 	;rcall	copy_word
                 	;
                 	
000192 0000      	nop
000193 0000      	nop
000194 0000      	nop
000195 0000      	nop
000196 0000      	nop
000197 0000      	nop
000198 0000      	nop
000199 0000      	nop
00019a 0000      	nop
00019b 0000      	nop
                 
00019c df2f      	rcall   decrypt      ; encryption routine
                 
00019d 0000      	nop
00019e 0000      	nop
00019f 0000      	nop
0001a0 0000      	nop
0001a1 0000      	nop
0001a2 0000      	nop
0001a3 0000      	nop
0001a4 0000      	nop
0001a5 0000      	nop
0001a6 0000      	nop
                 
0001a7 9ac0      	sbi		PORTB,0		; portA,0 = high (trigger on port A0)
0001a8 0000      	nop
0001a9 0000      	nop
0001aa 0000      	nop
0001ab 0000      	nop
0001ac 98c0       	cbi		PORTB,0		; portA,0 = low
                 
                 
                 	;make a pause
0001ad dfb5      	rcall	wait2
0001ae dfb4      	rcall	wait2
                 ;	rcall	wait2
                 ;	rcall	wait2
                 ;	rcall	wait2
                 
                 	;encrypt again, with the cipher as the new plain
0001af cfbe      	rjmp	main_loop
                 
                 
                 
                 
                 
                 
                 	;to decrypt:
                 	;ldi 	XH, high(SRAM_DATA)
                 	;ldi 	XL, low(SRAM_DATA)
                 	;rcall decrypt		; call decryption routine
                 
                 	;rjmp	main	;let's have fun one more time
                 
                 ;text:
                 ;.db $32,$43,$f6,$a8,$88,$5a,$30,$8d,$31,$31,$98,$a2,$e0,$37,$07,$34
                 ;key:
                 ;.db $2b,$7e,$15,$16,$28,$ae,$d2,$a6,$ab,$f7,$15,$88,$09,$cf,$4f,$3c,$51,$a4,$6b,$8d,$31,$1f,$f4,$37
                 
                 ;text:
                 ;.db $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
                 ;key:
                 ;.db $00,$00,$00,$00,$00,$00,$00,$00,$00,$00
                 
                 text:
                 ;.db $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
0001b0 0000
0001b1 0000
0001b2 0000
0001b3 0000      .db $00,$00,$00,$00,$00,$00,$00,$00
                 key:
0001b4 0000
0001b5 0000
0001b6 0000
0001b7 0000
0001b8 0000      .db $00,$00,$00,$00,$00,$00,$00,$00,$00,$00;,$00,$00,$00,$00,$00,$00
                 
                 ;text:
                 ;.db $7f,$f5,$fc,$04,$a5,$bc,$9e,$0a
                 ;key:
                 ;.db $ea,$85,$be,$fc,$86,$c6,$f1,$47,$c7,$ff,$7d,$7b,$88,$20,$83,$02
                 ;
                 ;b4db77b7e2560859
                 ;.db $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
                 ;ce 4d 0d b1 21 01 fb f7 0f 40 10 00
                 ;text:
                 ;.db $59,$08,$56,$e2,$b7,$77,$db,$b4
                 ;key:
                 ;.db $ce,$4d,$1d,$1b,$12,$fb,$f7,$0f,$04,$01
                 
                 
                 
                 ;text:
                 ;.db $f3,$44,$81,$ec,$3c,$c6,$27,$ba,$cd,$5d,$c3,$fb,$08,$f2,$73,$e6
                 ;.db $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
                 ;.db $32,$43,$f6,$a8,$88,$5a,$30,$8d,$31,$31,$98,$a2,$e0,$37,$07,$34
                 ;.db $20,$3e,$be,$9b,$b6,$fa,$fb,$eb,$65,$bc,$88,$23,$64,$0e,$02,$80
                 ;key:
                 ;.db $2b,$7e,$15,$16,$28,$ae,$d2,$a6,$ab,$f7,$15,$88,$09,$cf,$4f,$3c
                 ;.db $ff,$c0,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
                 ;.db $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
                 ;.db $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
                 ;.db $8b,$74,$f5,$8e,$9f,$49,$5e,$8f,$0a,$02,$ae,$bc,$d1,$63,$cd,$28
                 
                 .DSEG
000060             SRAM_PTEXT: .BYTE PTEXT_NUM_BYTE
000068             SRAM_KEY: .BYTE KEY_NUM_BYTE
000072             SRAM_SUBKEY: .BYTE KEYEXTENT_NUM_BYTE
                 ;******************** MAIN (END) *********************************
                 
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny45" register use summary:
r0 :  19 r1 :  17 r2 :  26 r3 :  24 r4 :  22 r5 :  18 r6 :  32 r7 :  26 
r8 :   5 r9 :   2 r10:   8 r11:   0 r12:   9 r13:   5 r14:   0 r15:   0 
r16:  23 r17:  14 r18:  19 r19:  11 r20:  16 r21:  11 r22:  17 r23:  12 
r24:  25 r25:  32 r26:   9 r27:  13 r28:   8 r29:   8 r30:  14 r31:  16 
x  :   1 y  :  90 z  :   2 
Registers used: 32 out of 35 (91.4%)

"ATtiny45" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   5 add   :   1 adiw  :   0 and   :  10 
andi  :  12 asr   :   0 bclr  :   0 bld   :   1 brbc  :   3 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :   0 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :   0 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   1 cbi   :   2 cbr   :   0 clc   :   0 
clh   :   0 cli   :   1 cln   :   0 clr   :   6 cls   :   0 clt   :   0 
clv   :   0 clz   :   0 com   :   5 cp    :   0 cpc   :   0 cpi   :   0 
cpse  :   3 dec   :   4 eor   :  84 icall :   0 ijmp  :   0 in    :   0 
inc   :   2 ld    :  58 ldd   :   0 ldi   :  38 lds   :   0 lpm   :   3 
lsl   :   5 lsr   :   0 mov   :   6 movw  :  15 neg   :   0 nop   :  53 
or    :  14 ori   :   0 out   :   3 pop   :   0 push  :   0 rcall :   8 
ret   :   6 reti  :   0 rjmp  :   5 rol   :   5 ror   :   2 sbc   :   0 
sbci  :   0 sbi   :   2 sbic  :   0 sbis  :   0 sbiw  :   0 sbr   :   0 
sbrc  :   0 sbrs  :   0 sec   :   0 seh   :   0 sei   :   0 sen   :   0 
ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 
spm   :   0 st    :  33 std   :   0 sts   :   0 sub   :   0 subi  :   0 
swap  :   8 tst   :   0 wdr   :   0 
Instructions used: 32 out of 105 (30.5%)

"ATtiny45" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000372    806     76    882    4096  21.5%
[.dseg] 0x000060 0x000142      0    226    226     256  88.3%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 14 warnings
