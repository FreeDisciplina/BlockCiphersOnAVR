
AVRASM ver. 2.1.57  F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm Fri Apr 24 16:20:43 2015

[builtin](2): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\tn45def.inc'
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(21): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\tn45def.inc'
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): Including file 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm'
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(9): warning: Use of undefined or forward referenced symbol 'SRAM_PTEXT' in .equ/.set
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(40): warning: Register r26 already defined by the .DEF directive
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(41): warning: Register r27 already defined by the .DEF directive
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(42): warning: Register r28 already defined by the .DEF directive
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(43): warning: Register r29 already defined by the .DEF directive
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(45): warning: .def: 'XL' redefinition (r26->r26)
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(45): warning: Register r26 already defined by the .DEF directive
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(46): warning: .def: 'XH' redefinition (r27->r27)
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(46): warning: Register r27 already defined by the .DEF directive
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(48): warning: .def: 'YL' redefinition (r28->r28)
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(48): warning: Register r28 already defined by the .DEF directive
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(49): warning: .def: 'YH' redefinition (r29->r29)
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(49): warning: Register r29 already defined by the .DEF directive
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(51): warning: Register r28 already defined by the .DEF directive
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(52): warning: Register r29 already defined by the .DEF directive
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(54): warning: .def: 'ZL' redefinition (r30->r30)
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(54): warning: Register r30 already defined by the .DEF directive
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(55): warning: .def: 'ZH' redefinition (r31->r31)
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(55): warning: Register r31 already defined by the .DEF directive
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
                 
                 /*
                 
                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny45.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "tn45def.inc"
                 ;* Title             : Register/Bit Definitions for the ATtiny45
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATtiny45
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _TN45DEF_INC_
                 #define _TN45DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATtiny45
                 #pragma AVRPART ADMIN PART_NAME ATtiny45
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x92
                 .equ	SIGNATURE_002	= 0x06
                 
                 #pragma AVRPART CORE CORE_VERSION V2
                 #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	GIMSK	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	TCCR0B	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	TCCR1	= 0x30
                 .equ	TCNT1	= 0x2f
                 .equ	OCR1A	= 0x2e
                 .equ	OCR1C	= 0x2d
                 .equ	GTCCR	= 0x2c
                 .equ	OCR1B	= 0x2b
                 .equ	TCCR0A	= 0x2a
                 .equ	OCR0A	= 0x29
                 .equ	OCR0B	= 0x28
                 .equ	PLLCSR	= 0x27
                 .equ	CLKPR	= 0x26
                 .equ	DT1A	= 0x25
                 .equ	DT1B	= 0x24
                 .equ	DTPS	= 0x23
                 .equ	DWDR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	PRR	= 0x20
                 .equ	EEARH	= 0x1f
                 .equ	EEARL	= 0x1e
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PCMSK	= 0x15
                 .equ	DIDR0	= 0x14
                 .equ	GPIOR2	= 0x13
                 .equ	GPIOR1	= 0x12
                 .equ	GPIOR0	= 0x11
                 .equ	USIBR	= 0x10
                 .equ	USIDR	= 0x0f
                 .equ	USISR	= 0x0e
                 .equ	USICR	= 0x0d
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCH	= 0x05
                 .equ	ADCL	= 0x04
                 .equ	ADCSRB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** PORTB ************************
                 ; PORTB - Data Register, Port B
                 .equ	PORTB0	= 0	; 
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; 
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; 
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; 
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; 
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; 
                 .equ	PB5	= 5	; For compatibility
                 
                 ; DDRB - Data Direction Register, Port B
                 .equ	DDB0	= 0	; 
                 .equ	DDB1	= 1	; 
                 .equ	DDB2	= 2	; 
                 .equ	DDB3	= 3	; 
                 .equ	DDB4	= 4	; 
                 .equ	DDB5	= 5	; 
                 
                 ; PINB - Input Pins, Port B
                 .equ	PINB0	= 0	; 
                 .equ	PINB1	= 1	; 
                 .equ	PINB2	= 2	; 
                 .equ	PINB3	= 3	; 
                 .equ	PINB4	= 4	; 
                 .equ	PINB5	= 5	; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	AINBG	= ACBG	; For compatibility
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR0 - 
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	REFS2	= 4	; Reference Selection Bit 2
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                 .equ	IPR	= 5	; Input Polarity Mode
                 .equ	BIN	= 7	; Bipolar Input Mode
                 
                 ; DIDR0 - Digital Input Disable Register 0
                 .equ	ADC1D	= 2	; ADC1 Digital input Disable
                 .equ	ADC3D	= 3	; ADC3 Digital input Disable
                 .equ	ADC2D	= 4	; ADC2 Digital input Disable
                 .equ	ADC0D	= 5	; ADC0 Digital input Disable
                 
                 
                 ; ***** USI **************************
                 ; USIBR - USI Buffer Register
                 .equ	USIBR0	= 0	; USI Buffer Register bit 0
                 .equ	USIBR1	= 1	; USI Buffer Register bit 1
                 .equ	USIBR2	= 2	; USI Buffer Register bit 2
                 .equ	USIBR3	= 3	; USI Buffer Register bit 3
                 .equ	USIBR4	= 4	; USI Buffer Register bit 4
                 .equ	USIBR5	= 5	; USI Buffer Register bit 5
                 .equ	USIBR6	= 6	; USI Buffer Register bit 6
                 .equ	USIBR7	= 7	; USI Buffer Register bit 7
                 
                 ; USIDR - USI Data Register
                 .equ	USIDR0	= 0	; USI Data Register bit 0
                 .equ	USIDR1	= 1	; USI Data Register bit 1
                 .equ	USIDR2	= 2	; USI Data Register bit 2
                 .equ	USIDR3	= 3	; USI Data Register bit 3
                 .equ	USIDR4	= 4	; USI Data Register bit 4
                 .equ	USIDR5	= 5	; USI Data Register bit 5
                 .equ	USIDR6	= 6	; USI Data Register bit 6
                 .equ	USIDR7	= 7	; USI Data Register bit 7
                 
                 ; USISR - USI Status Register
                 .equ	USICNT0	= 0	; USI Counter Value Bit 0
                 .equ	USICNT1	= 1	; USI Counter Value Bit 1
                 .equ	USICNT2	= 2	; USI Counter Value Bit 2
                 .equ	USICNT3	= 3	; USI Counter Value Bit 3
                 .equ	USIDC	= 4	; Data Output Collision
                 .equ	USIPF	= 5	; Stop Condition Flag
                 .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
                 .equ	USISIF	= 7	; Start Condition Interrupt Flag
                 
                 ; USICR - USI Control Register
                 .equ	USITC	= 0	; Toggle Clock Port Pin
                 .equ	USICLK	= 1	; Clock Strobe
                 .equ	USICS0	= 2	; USI Clock Source Select Bit 0
                 .equ	USICS1	= 3	; USI Clock Source Select Bit 1
                 .equ	USIWM0	= 4	; USI Wire Mode Bit 0
                 .equ	USIWM1	= 5	; USI Wire Mode Bit 1
                 .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
                 .equ	USISIE	= 7	; Start Condition Interrupt Enable
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; MCUCR - MCU Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 
                 ; GIMSK - General Interrupt Mask Register
                 .equ	GICR	= GIMSK	; For compatibility
                 .equ	PCIE	= 5	; Pin Change Interrupt Enable
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 
                 ; GIFR - General Interrupt Flag register
                 .equ	PCIF	= 5	; Pin Change Interrupt Flag
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 
                 ; PCMSK - Pin Change Enable Mask
                 .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 0
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0B	= 3	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 .equ	OCIE0A	= 4	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 
                 ; TIFR - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                 .equ	OCF0B	= 3	; Timer/Counter0 Output Compare Flag 0B
                 .equ	OCF0A	= 4	; Timer/Counter0 Output Compare Flag 0A
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCR0_0	= 0	; 
                 .equ	OCR0_1	= 1	; 
                 .equ	OCR0_2	= 2	; 
                 .equ	OCR0_3	= 3	; 
                 .equ	OCR0_4	= 4	; 
                 .equ	OCR0_5	= 5	; 
                 .equ	OCR0_6	= 6	; 
                 .equ	OCR0_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 ;.equ	OCR0_0	= 0	; 
                 ;.equ	OCR0_1	= 1	; 
                 ;.equ	OCR0_2	= 2	; 
                 ;.equ	OCR0_3	= 3	; 
                 ;.equ	OCR0_4	= 4	; 
                 ;.equ	OCR0_5	= 5	; 
                 ;.equ	OCR0_6	= 6	; 
                 ;.equ	OCR0_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSR0	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TCCR1 - Timer/Counter Control Register
                 .equ	CS10	= 0	; Clock Select Bits
                 .equ	CS11	= 1	; Clock Select Bits
                 .equ	CS12	= 2	; Clock Select Bits
                 .equ	CS13	= 3	; Clock Select Bits
                 .equ	COM1A0	= 4	; Compare Output Mode, Bit 1
                 .equ	COM1A1	= 5	; Compare Output Mode, Bit 0
                 .equ	PWM1A	= 6	; Pulse Width Modulator Enable
                 .equ	CTC1	= 7	; Clear Timer/Counter on Compare Match
                 
                 ; TCNT1 - Timer/Counter Register
                 .equ	TCNT1_0	= 0	; Timer/Counter Register Bit 0
                 .equ	TCNT1_1	= 1	; Timer/Counter Register Bit 1
                 .equ	TCNT1_2	= 2	; Timer/Counter Register Bit 2
                 .equ	TCNT1_3	= 3	; Timer/Counter Register Bit 3
                 .equ	TCNT1_4	= 4	; Timer/Counter Register Bit 4
                 .equ	TCNT1_5	= 5	; Timer/Counter Register Bit 5
                 .equ	TCNT1_6	= 6	; Timer/Counter Register Bit 6
                 .equ	TCNT1_7	= 7	; Timer/Counter Register Bit 7
                 
                 ; OCR1A - Output Compare Register
                 .equ	OCR1A0	= 0	; Output Compare Register A Bit 0
                 .equ	OCR1A1	= 1	; Output Compare Register A Bit 1
                 .equ	OCR1A2	= 2	; Output Compare Register A Bit 2
                 .equ	OCR1A3	= 3	; Output Compare Register A Bit 3
                 .equ	OCR1A4	= 4	; Output Compare Register A Bit 4
                 .equ	OCR1A5	= 5	; Output Compare Register A Bit 5
                 .equ	OCR1A6	= 6	; Output Compare Register A Bit 6
                 .equ	OCR1A7	= 7	; Output Compare Register A Bit 7
                 
                 ; OCR1B - Output Compare Register
                 .equ	OCR1B0	= 0	; Output Compare Register B Bit 0
                 .equ	OCR1B1	= 1	; Output Compare Register B Bit 1
                 .equ	OCR1B2	= 2	; Output Compare Register B Bit 2
                 .equ	OCR1B3	= 3	; Output Compare Register B Bit 3
                 .equ	OCR1B4	= 4	; Output Compare Register B Bit 4
                 .equ	OCR1B5	= 5	; Output Compare Register B Bit 5
                 .equ	OCR1B6	= 6	; Output Compare Register B Bit 6
                 .equ	OCR1B7	= 7	; Output Compare Register B Bit 7
                 
                 ; OCR1C - Output compare register
                 .equ	OCR1C0	= 0	; 
                 .equ	OCR1C1	= 1	; 
                 .equ	OCR1C2	= 2	; 
                 .equ	OCR1C3	= 3	; 
                 .equ	OCR1C4	= 4	; 
                 .equ	OCR1C5	= 5	; 
                 .equ	OCR1C6	= 6	; 
                 .equ	OCR1C7	= 7	; 
                 
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 5	; OCIE1A: Timer/Counter1 Output Compare B Interrupt Enable
                 .equ	OCIE1A	= 6	; OCIE1A: Timer/Counter1 Output Compare Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 5	; Timer/Counter1 Output Compare Flag 1B
                 .equ	OCF1A	= 6	; Timer/Counter1 Output Compare Flag 1A
                 
                 ; GTCCR - Timer counter control register
                 .equ	PSR1	= 1	; Prescaler Reset Timer/Counter1
                 .equ	FOC1A	= 2	; Force Output Compare 1A
                 .equ	FOC1B	= 3	; Force Output Compare Match 1B
                 .equ	COM1B0	= 4	; Comparator B Output Mode
                 .equ	COM1B1	= 5	; Comparator B Output Mode
                 .equ	PWM1B	= 6	; Pulse Width Modulator B Enable
                 
                 ; DTPS - Dead time prescaler register
                 .equ	DTPS0	= 0	; 
                 .equ	DTPS1	= 1	; 
                 
                 ; DT1A - Dead time value register
                 .equ	DTVL0	= 0	; 
                 .equ	DTVL1	= 1	; 
                 .equ	DTVL2	= 2	; 
                 .equ	DTVL3	= 3	; 
                 .equ	DTVH0	= 4	; 
                 .equ	DTVH1	= 5	; 
                 .equ	DTVH2	= 6	; 
                 .equ	DTVH3	= 7	; 
                 
                 ; DT1B - Dead time value B
                 ;.equ	DTVL0	= 0	; 
                 ;.equ	DTVL1	= 1	; 
                 ;.equ	DTVL2	= 2	; 
                 ;.equ	DTVL3	= 3	; 
                 ;.equ	DTVH0	= 4	; 
                 ;.equ	DTVH1	= 5	; 
                 ;.equ	DTVH2	= 6	; 
                 ;.equ	DTVH3	= 7	; 
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                 .equ	BODSE	= 2	; BOD Sleep Enable
                 .equ	SM0	= 3	; Sleep Mode Select Bit 0
                 .equ	SM1	= 4	; Sleep Mode Select Bit 1
                 .equ	SE	= 5	; Sleep Enable
                 .equ	PUD	= 6	; Pull-up Disable
                 .equ	BODS	= 7	; BOD Sleep
                 
                 ; MCUSR - MCU Status register
                 .equ	PORF	= 0	; Power-On Reset Flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSI	= 1	; Power Reduction USI
                 .equ	PRTIM0	= 2	; Power Reduction Timer/Counter0
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 
                 ; OSCCAL - Oscillator Calibration Register
                 .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
                 .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
                 .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
                 .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
                 .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
                 .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
                 .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
                 .equ	CAL7	= 7	; Oscillatro Calibration Value Bit 7
                 
                 ; PLLCSR - PLL Control and status register
                 .equ	PLOCK	= 0	; PLL Lock detector
                 .equ	PLLE	= 1	; PLL Enable
                 .equ	PCKE	= 2	; PCK Enable
                 .equ	LSM	= 7	; Low speed mode
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; DWDR - debugWire data register
                 .equ	DWDR0	= 0	; 
                 .equ	DWDR1	= 1	; 
                 .equ	DWDR2	= 2	; 
                 .equ	DWDR3	= 3	; 
                 .equ	DWDR4	= 4	; 
                 .equ	DWDR5	= 5	; 
                 .equ	DWDR6	= 6	; 
                 .equ	DWDR7	= 7	; 
                 
                 ; GPIOR2 - General Purpose IO register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General purpose register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCSR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	RFLB	= 3	; Read fuse and lock bits
                 .equ	CTPB	= 4	; Clear temporary page buffer
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lockbit
                 .equ	LB2	= 1	; Lockbit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock source
                 .equ	CKSEL1	= 1	; Select Clock source
                 .equ	CKSEL2	= 2	; Select Clock source
                 .equ	CKSEL3	= 3	; Select Clock source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock Output Enable
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through the Chip Erase
                 .equ	WDTON	= 4	; Watchdog Timer always on
                 .equ	SPIEN	= 5	; Enable Serial Program and Data Downloading
                 .equ	DWEN	= 6	; DebugWIRE Enable
                 .equ	RSTDISBL	= 7	; External Reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	SELFPRGEN	= 0	; Self-Programming Enable
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x07ff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 256
                 .equ	RAMEND	= 0x015f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x00ff
                 .equ	EEPROMEND	= 0x00ff
                 .equ	EEADRBITS	= 8
                 #pragma AVRPART MEMORY PROG_FLASH 4096
                 #pragma AVRPART MEMORY EEPROM 256
                 #pragma AVRPART MEMORY INT_SRAM SIZE 256
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x0
                 .equ	NRWW_STOP_ADDR	= 0x7ff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x0
                 .equ	PAGESIZE	= 32
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt 0
                 .equ	PCI0addr	= 0x0002	; Pin change Interrupt Request 0
                 .equ	OC1Aaddr	= 0x0003	; Timer/Counter1 Compare Match 1A
                 .equ	OVF1addr	= 0x0004	; Timer/Counter1 Overflow
                 .equ	OVF0addr	= 0x0005	; Timer/Counter0 Overflow
                 .equ	ERDYaddr	= 0x0006	; EEPROM Ready
                 .equ	ACIaddr	= 0x0007	; Analog comparator
                 .equ	ADCCaddr	= 0x0008	; ADC Conversion ready
                 .equ	OC1Baddr	= 0x0009	; Timer/Counter1 Compare Match B
                 .equ	OC0Aaddr	= 0x000a	; Timer/Counter0 Compare Match A
                 .equ	OC0Baddr	= 0x000b	; Timer/Counter0 Compare Match B
                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out
                 .equ	USI_STARTaddr	= 0x000d	; USI START
                 .equ	USI_OVFaddr	= 0x000e	; USI Overflow
                 
                 .equ	INT_VECTORS_SIZE	= 15	; size in words
                 
                 #endif  /* _TN45DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                  * interface.asm
                  *
                  *  Created: 2015/4/23 23:35:49
                  *   Author: nevermore
                  */ 
                 
                 
                  /*
                  * interface.asm
                  *
                  *  Created: 2015/4/22 11:35:06
                  *   Author: Zheng Gong
                  */ 
                  ; encrypt_main_tiny45 : generates the plain text and key internally,
                 ; sends a trigger, encrypts and sends a second trigger
                 ; based on http://point-at-infinity.org/avraes/rijndaelfurious.asm.html
                 
                 ; modify the interface by humuchuang because the label "SRAM_DATA" cannot be recognized by the file KLEIN.asm
                 
                 .include "tn45def.inc"
                 
                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny45.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "tn45def.inc"
                 ;* Title             : Register/Bit Definitions for the ATtiny45
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATtiny45
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _TN45DEF_INC_
                 #endif  /* _TN45DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 ; Define the cipher to include here (#define <cipher>)
                 #define	rectangle;(currently works for aes, desxl, hight, idea, kasumi, katan, klein, mcrypton, noekeon, present, sea, tea)
                 
                 
                 .ORG 0x0000
                 ; global interrupt disable
000000 94f8      	cli
                 ; initialize stack
000001 e0f1      	ldi		r31,HIGH(RAMEND)
000002 bffe      	out		SPH,r31
000003 e5ff      	ldi		r31,LOW(RAMEND)
000004 bffd      	out		SPL,r31
                 
                 ; initialize trigger B1
000005 e003        	ldi		r16, 0b11	; portB,1 = output (triggers)
000006 bb07        	out		DDRB, r16
                 
000007 c21d      	rjmp	main
                 
                 
                 ;******************* INCLUDE FILES *******************************
                 ; include encryption algorithm
                 #ifdef	aes
                 #elif aesfurious
                 #elif rectangle
                     .include "./Rectangle128OnTheFly.asm";"Rectangle80OnTheFly.asm";"Rectangle80.asm"
                 
                 ; Constants
                 ;
                 .EQU    PTEXT_NUM_BYTE = 8
                 .EQU    CTEXT_NUM_BYTE = 8
                 .EQU    KEY_NUM_BYTE = 16
                 .EQU	ADD_MEM_NUM_BYTE = 0 ;Additional memory for internal computation
                 .EQU	TOT_NUM_BYTE = PTEXT_NUM_BYTE+KEY_NUM_BYTE+ADD_MEM_NUM_BYTE
                 .EQU    SRAM_CTEXT = SRAM_PTEXT
                 
                 ; Registers declarations
                 .def k0 =r0
                 .def k1 =r1
                 .def k2 =r2
                 .def k3 =r3
                 .def k4 =r4
                 .def k5 =r5
                 .def k6 =r6
                 .def k7 =r7
                 .def k8 =r8
                 .def k9 =r9
                 .def k10=r10
                 .def k11=r11
                 .def k12=r12
                 .def k13=r13
                 .def k14=r14
                 .def k15=r15
                 
                 .def s0 =r16
                 .def s1 =r17
                 .def s2 =r18
                 .def s3 =r19
                 .def s4 =r20
                 .def s5 =r21
                 .def s6 =r22
                 .def s7 =r23
                 
                 .def t0 =r24
                 .def t1 =r25
                 .def t2 =r26
                 .def t3 =r27
                 .def t4 =r28
                 .def t5 =r29
                 
                 .def XL =r26
                 .def XH =r27
                 
                 .def YL =r28
                 .def YH =r29
                 
                 .def rcnt  =r28
                 .def rzero =r29
                 
                 .def ZL =r30
                 .def ZH =r31
                 
                 ;*****************************************************************************
                 ;;; load_key
                 ;;; 
                 ;;; load master key to:
                 ;;; r3:r2:r1:r0
                 ;;; r7:r6:r5:r4
                 ;;; r11:r10:r9:r8
                 ;;; r15:r14:r13:r12
                 
                 .MACRO load_key
                 	ld  k0,  Z+
                 	ld  k1,  Z+
                 	ld  k2,  Z+
                 	ld  k3,  Z+
                 	ld  k4,  Z+
                 	ld  k5,  Z+
                 	ld  k6,  Z+
                 	ld  k7,  Z+
                 	ld  k8,  Z+
                 	ld  k9,  Z+
                 	ld  k10, Z+
                 	ld  k11, Z+
                 	ld  k12, Z+
                 	ld  k13, Z+
                 	ld  k14, Z+
                 	ld  k15, Z
                 .ENDMACRO
                 
                 ;;;****************************************************************************
                 ;;;
                 ;;; load_input
                 ;;;
                 .MACRO load_input
                 	ld  s0, Z+
                 	ld  s1, Z+
                 	ld  s2, Z+
                 	ld  s3, Z+
                 	ld  s4, Z+
                 	ld  s5, Z+
                 	ld  s6, Z+
                 	ld  s7, Z
                 .ENDMACRO
                 
                 
                 ;;;****************************************************************************
                 ;;;
                 ;;; store_output
                 ;;; 
                 .MACRO store_output
                 	st  Z+, s0
                 	st  Z+, s1
                 	st  Z+, s2
                 	st  Z+, s3
                 	st  Z+, s4
                 	st  Z+, s5
                 	st  Z+, s6
                 	st  Z , s7
                 .ENDMACRO
                 
                 ;;;****************************************************************************
                 ;;;
                 ;;; add_round_key
                 .MACRO add_round_key
                 eor s0, k0	
                 eor s1, k1	
                 eor s2, k4	
                 eor s3, k5	
                 eor s4, k8	
                 eor s5, k9	
                 eor s6, k12
                 eor s7, k13
                 .ENDMACRO
                 
                 .MACRO forward_key_sbox
                     eor t0, t0				; 1 ins, 1 clock
                     eor t1, t1				; 1 ins, 1 clock
                 ;
                     ror k12						; 1 ins, 1 clock
                     rol t0						; 1 ins, 1 clock
                     ror k8						; 1 ins, 1 clock
                     rol t0						; 1 ins, 1 clock
                     ror k4						; 1 ins, 1 clock
                     rol t0						; 1 ins, 1 clock
                     ror k0						; 1 ins, 1 clock
                     rol t0						; 1 ins, 1 clock
                 ;
                     ldi ZH, high(Sbox<<1)			; 1 ins, 1 clock
                     ldi ZL, low(Sbox<<1)			; 1 ins, 1 clock
                     add ZL, t0					; 1 ins, 1 clock
                     lpm t0, Z					; 1 ins, 3 clocks
                 ;
                     ror k12						; 1 ins, 1 clock
                     rol t1						; 1 ins, 1 clock
                     ror k8						; 1 ins, 1 clock
                     rol t1						; 1 ins, 1 clock
                     ror k4						; 1 ins, 1 clock
                     rol t1						; 1 ins, 1 clock
                     ror k0						; 1 ins, 1 clock
                     rol t1						; 1 ins, 1 clock
                 ;
                     ldi ZH, high(Sbox<<1)			; 1 ins, 1 clock
                     ldi ZL, low(Sbox<<1)			; 1 ins, 1 clock
                     add ZL, t1					; 1 ins, 1 clock
                     lpm t1, Z					; 1 ins, 3 clocks
                 ;
                     ror t1						; 1 ins, 1 clock
                     rol k0						; 1 ins, 1 clock
                     ror t1						; 1 ins, 1 clock
                     rol k4						; 1 ins, 1 clock
                     ror t1						; 1 ins, 1 clock
                     rol k8						; 1 ins, 1 clock
                     ror t1						; 1 ins, 1 clock
                     rol k12						; 1 ins, 1 clock
                 ;
                     ror t0						; 1 ins, 1 clock
                     rol k0						; 1 ins, 1 clock
                     ror t0						; 1 ins, 1 clock
                     rol k4						; 1 ins, 1 clock
                     ror t0						; 1 ins, 1 clock
                     rol k8						; 1 ins, 1 clock
                     ror t0						; 1 ins, 1 clock
                     rol k12						; 1 ins, 1 clock
                 .ENDMACRO
                 
                 .MACRO invert_key_sbox
                     eor t0, t0				; 1 ins, 1 clock
                     eor t1, t1				; 1 ins, 1 clock
                 ;
                     ror k12						; 1 ins, 1 clock
                     rol t0						; 1 ins, 1 clock
                     ror k8						; 1 ins, 1 clock
                     rol t0						; 1 ins, 1 clock
                     ror k4						; 1 ins, 1 clock
                     rol t0						; 1 ins, 1 clock
                     ror k0						; 1 ins, 1 clock
                     rol t0						; 1 ins, 1 clock
                 ;
                     ldi ZH, high(ISbox<<1)			; 1 ins, 1 clock
                     ldi ZL, low(ISbox<<1)			; 1 ins, 1 clock
                     add ZL, t0					; 1 ins, 1 clock
                     lpm t0, Z					; 1 ins, 3 clocks
                 ;
                     ror k12						; 1 ins, 1 clock
                     rol t1						; 1 ins, 1 clock
                     ror k8						; 1 ins, 1 clock
                     rol t1						; 1 ins, 1 clock
                     ror k4						; 1 ins, 1 clock
                     rol t1						; 1 ins, 1 clock
                     ror k0						; 1 ins, 1 clock
                     rol t1						; 1 ins, 1 clock
                 ;
                     ldi ZH, high(ISbox<<1)			; 1 ins, 1 clock
                     ldi ZL, low(ISbox<<1)			; 1 ins, 1 clock
                     add ZL, t1					; 1 ins, 1 clock
                     lpm t1, Z					; 1 ins, 3 clocks
                 ;
                     ror t1						; 1 ins, 1 clock
                     rol k0						; 1 ins, 1 clock
                     ror t1						; 1 ins, 1 clock
                     rol k4						; 1 ins, 1 clock
                     ror t1						; 1 ins, 1 clock
                     rol k8						; 1 ins, 1 clock
                     ror t1						; 1 ins, 1 clock
                     rol k12						; 1 ins, 1 clock
                 ;
                     ror t0						; 1 ins, 1 clock
                     rol k0						; 1 ins, 1 clock
                     ror t0						; 1 ins, 1 clock
                     rol k4						; 1 ins, 1 clock
                     ror t0						; 1 ins, 1 clock
                     rol k8						; 1 ins, 1 clock
                     ror t0						; 1 ins, 1 clock
                     rol k12						; 1 ins, 1 clock
                 .ENDMACRO
                 
                 ;;; 
                 ;;; r3:r2:r1:r0   <<<  10 =
                 ;;; r3:r2:r1:r0   <<<  8
                 ;;; r3:r2:r1:r0   <<<  2
                 ;;; 
                  ;left_rotate32_8 (k0, k1, k2, k3, t0)
                  ;left_rotate32_2 (k0, k1, k2, k3, t0)
                 .MACRO forward_rotate_row0
                     mov t0, k3
                     mov k3, k2					
                     mov k2, k1					
                     mov k1, k0					
                     mov k0, t0					
                     lsl k0
                     rol k1
                     rol k2
                     rol k3
                     adc k0, rzero
                     lsl k0
                     rol k1
                     rol k2
                     rol k3
                     adc k0, rzero
                 .ENDMACRO
                 
                 ;;; 
                 ;;; r7:r6:r5:r4   <<<  14 =
                 ;;; r7:r6:r5:r4   <<<  16
                 ;;; r7:r6:r5:r4   >>>  2
                 ;;; 
                 ; left_rotate32_16 (k4, k5, k6, k7, t0)
                 ; right_rotate32_2 (k4, k5, k6, k7, t0)
                 .MACRO forward_rotate_row1
                     movw t0, k6
                     movw k6, k4					
                     movw k4, t0					
                     mov t0, k4
                     lsr t0
                     ror k7
                     ror k6
                     ror k5
                     ror k4
                     lsr t0
                     ror k7
                     ror k6
                     ror k5
                     ror k4
                 .ENDMACRO
                  
                 ;;; 
                 ;;; r11:r10:r9:r8   <<< 18 =
                 ;;; r11:r10:r9:r8   <<< 16
                 ;;; r11:r10:r9:r8   <<< 2
                 ;;; 
                 ; left_rotate32_16 (k8, k9, k10, k11, t0)
                 ; left_rotate32_2  (k8, k9, k10, k11, t0)
                 .MACRO forward_rotate_row2
                     movw t0, k10
                     movw k10, k8					
                     movw k8, t0					
                     lsl k8
                     rol k9
                     rol k10
                     rol k11
                     adc k8, rzero
                     lsl k8
                     rol k9
                     rol k10
                     rol k11
                     adc k8, rzero
                 .ENDMACRO
                 
                 
                 ;;; 
                 ;;; r15:r14:r13:r12 <<< 22 =
                 ;;; r15:r14:r13:r12 >>> 10 =
                 ;;; r15:r14:r13:r12 >>>  8
                 ;;; r15:r14:r13:r12 >>>  2
                 ;;; 
                 ; right_rotate32_8 (k12, k13, k14, k15, t0)
                 ; right_rotate32_2 (k12, k13, k14, k15, t0)
                 .MACRO forward_rotate_row3
                     mov t0, k12					
                     mov k12, k13					
                     mov k13, k14					
                     mov k14, k15
                     mov k15, t0					
                     mov t0, k12
                     lsr t0
                     ror k15
                     ror k14
                     ror k13
                     ror k12
                     lsr t0
                     ror k15
                     ror k14
                     ror k13
                     ror k12
                 .ENDMACRO
                 
                 ;;; 
                 ;;; r3:r2:r1:r0   >>>  10 =
                 ;;; r3:r2:r1:r0   >>>  8
                 ;;; r3:r2:r1:r0   >>>  2
                 ;;; 
                 ; right_rotate32_8 (k0, k1, k2, k3, t0)
                 ; right_rotate32_2 (k0, k1, k2, k3, t0)
                 .MACRO invert_rotate_row0
                     mov t0, k0					
                     mov k0, k1					
                     mov k1, k2					
                     mov k2, k3
                     mov k3, t0					
                     mov t0, k0
                     lsr t0
                     ror k3
                     ror k2
                     ror k1
                     ror k0
                     lsr t0
                     ror k3
                     ror k2
                     ror k1
                     ror k0
                 .ENDMACRO
                 
                 
                 ;;; 
                 ;;; r7:r6:r5:r4   >>>  14 =
                 ;;; r7:r6:r5:r4   >>>  16
                 ;;; r7:r6:r5:r4   <<<  2
                 ;;; 
                 ; right_rotate32_16 (k4, k5, k6, k7, t0)
                 ; left_rotate32_2   (k4, k5, k6, k7, t0)
                 .MACRO invert_rotate_row1
                     movw t0, k6
                     movw k6, k4					
                     movw k4, t0					
                     lsl k4
                     rol k5
                     rol k6
                     rol k7
                     adc k4, rzero
                     lsl k4
                     rol k5
                     rol k6
                     rol k7
                     adc k4, rzero
                 .ENDMACRO
                  
                 ;;; 
                 ;;; r11:r10:r9:r8   <<< 18 =
                 ;;; r11:r10:r9:r8   >>> 16
                 ;;; r11:r10:r9:r8   >>> 2
                 ;;; 
                 ; right_rotate32_16 (k8, k9, k10, k11, t0)                ;3 ins, 3 clocks +
                 ; right_rotate32_2  (k8, k9, k10, k11, t0)                ;10 ins, 10 clocks =
                 ;								;13 ins, 13 clocks
                 .MACRO invert_rotate_row2
                     movw t0, k10
                     movw k10, k8					
                     movw k8, t0					
                     mov t0, k8
                     lsr t0
                     ror k11
                     ror k10
                     ror k9
                     ror k8
                     lsr t0
                     ror k11
                     ror k10
                     ror k9
                     ror k8
                 .ENDMACRO
                 
                 
                 ;;; 
                 ;;; r15:r14:r13:r12 >>> 22 =
                 ;;; r15:r14:r13:r12 <<< 10 =
                 ;;; r15:r14:r13:r12 <<<  8
                 ;;; r15:r14:r13:r12 <<<  2
                 ;;; 
                 ; left_rotate32_8 (k12, k13, k14, k15, t0)               ;5 ins, 5 clocks +
                 ; left_rotate32_2 (k12, k13, k14, k15, t0)               ;11 ins, 11 clocks =
                 ;								;16 ins, 16 clocks
                 .MACRO invert_rotate_row3
                     mov t0, k15
                     mov k15, k14					
                     mov k14, k13					
                     mov k13, k12					
                     mov k12, t0					
                     lsl k12
                     rol k13
                     rol k14
                     rol k15
                     adc k12, rzero
                     lsl k12
                     rol k13
                     rol k14
                     rol k15
                     adc k12, rzero
                 .ENDMACRO
                 
                 .MACRO key_addRC
                   ldi ZH, high(RC<<1)			; 1 ins, 1 clock
                   ldi ZL, low(RC<<1)			; 1 ins, 1 clock
                   add ZL, rcnt				; 1 ins, 1 clock
                   lpm t0, Z				; 1 ins, 3 clocks
                   eor k0, t0				; 1 ins, 1 clock
                 .ENDMACRO
                 
                 /*.MACRO forward_key_update
                 	forward_key_sbox
                 	forward_rotate_row0
                 	forward_rotate_row1
                 	forward_rotate_row2
                 	forward_rotate_row3
                 	key_addRC
                 .ENDMACRO
                 
                 
                 .MACRO invert_key_update
                 	key_addRC
                 	invert_rotate_row0
                 	invert_rotate_row1
                 	invert_rotate_row2
                 	invert_rotate_row3
                 	invert_key_sbox
                 .ENDMACRO
                 */
                 
                 forward_key_update:
000008 2788
000009 2799
00000a 94c7
00000b 1f88
00000c 9487
00000d 1f88
00000e 9447
00000f 1f88
000010 9407
000011 1f88
000012 e0f3
000013 eeea
000014 0fe8
000015 9184
000016 94c7
000017 1f99
000018 9487
000019 1f99
00001a 9447
00001b 1f99
00001c 9407
00001d 1f99
00001e e0f3
00001f eeea
000020 0fe9
000021 9194
000022 9597
000023 1c00
000024 9597
000025 1c44
000026 9597
000027 1c88
000028 9597
000029 1ccc
00002a 9587
00002b 1c00
00002c 9587
00002d 1c44
00002e 9587
00002f 1c88
000030 9587
000031 1ccc      	forward_key_sbox
000032 27dd      	clr rzero
000033 2d83
000034 2c32
000035 2c21
000036 2c10
000037 2e08
000038 0c00
000039 1c11
00003a 1c22
00003b 1c33
00003c 1e0d
00003d 0c00
00003e 1c11
00003f 1c22
000040 1c33
000041 1e0d      	forward_rotate_row0
000042 01c3
000043 0132
000044 012c
000045 2d84
000046 9586
000047 9477
000048 9467
000049 9457
00004a 9447
00004b 9586
00004c 9477
00004d 9467
00004e 9457
00004f 9447      	forward_rotate_row1
000050 01c5
000051 0154
000052 014c
000053 0c88
000054 1c99
000055 1caa
000056 1cbb
000057 1e8d
000058 0c88
000059 1c99
00005a 1caa
00005b 1cbb
00005c 1e8d      	forward_rotate_row2
00005d 2d8c
00005e 2ccd
00005f 2cde
000060 2cef
000061 2ef8
000062 2d8c
000063 9586
000064 94f7
000065 94e7
000066 94d7
000067 94c7
000068 9586
000069 94f7
00006a 94e7
00006b 94d7
00006c 94c7      	forward_rotate_row3
00006d e0f4
00006e e0ea
00006f 0fec
000070 9184
000071 2608      	key_addRC
000072 9508      	ret
                 
                 
                 invert_key_update:
000073 e0f4
000074 e0ea
000075 0fec
000076 9184
000077 2608      	key_addRC
000078 27dd      	clr rzero
000079 2d80
00007a 2c01
00007b 2c12
00007c 2c23
00007d 2e38
00007e 2d80
00007f 9586
000080 9437
000081 9427
000082 9417
000083 9407
000084 9586
000085 9437
000086 9427
000087 9417
000088 9407      	invert_rotate_row0
000089 01c3
00008a 0132
00008b 012c
00008c 0c44
00008d 1c55
00008e 1c66
00008f 1c77
000090 1e4d
000091 0c44
000092 1c55
000093 1c66
000094 1c77
000095 1e4d      	invert_rotate_row1
000096 01c5
000097 0154
000098 014c
000099 2d88
00009a 9586
00009b 94b7
00009c 94a7
00009d 9497
00009e 9487
00009f 9586
0000a0 94b7
0000a1 94a7
0000a2 9497
0000a3 9487      	invert_rotate_row2
0000a4 2d8f
0000a5 2cfe
0000a6 2ced
0000a7 2cdc
0000a8 2ec8
0000a9 0ccc
0000aa 1cdd
0000ab 1cee
0000ac 1cff
0000ad 1ecd
0000ae 0ccc
0000af 1cdd
0000b0 1cee
0000b1 1cff
0000b2 1ecd      	invert_rotate_row3
0000b3 2788
0000b4 2799
0000b5 94c7
0000b6 1f88
0000b7 9487
0000b8 1f88
0000b9 9447
0000ba 1f88
0000bb 9407
0000bc 1f88
0000bd e0f3
0000be efea
0000bf 0fe8
0000c0 9184
0000c1 94c7
0000c2 1f99
0000c3 9487
0000c4 1f99
0000c5 9447
0000c6 1f99
0000c7 9407
0000c8 1f99
0000c9 e0f3
0000ca efea
0000cb 0fe9
0000cc 9194
0000cd 9597
0000ce 1c00
0000cf 9597
0000d0 1c44
0000d1 9597
0000d2 1c88
0000d3 9597
0000d4 1ccc
0000d5 9587
0000d6 1c00
0000d7 9587
0000d8 1c44
0000d9 9587
0000da 1c88
0000db 9587
0000dc 1ccc      	invert_key_sbox
0000dd 9508      	ret
                 
                 ;;;****************************************************************************
                 ;;;
                 ;;; substitute sbox
                 ;input/output state s1:s0: a
                 ;input/output state s3:s2: b
                 ;input/output state s5:s4: c
                 ;input/output state s7:s6: d
                 
                 ; temporary register t1:t0
                 ; temporary register t3:t2
                 ; temporary register t5:t4
                 
                 .MACRO forward_sbox
                 	push rcnt
                     movw t0, s2
                     com  s2
                     com  s3
                     
                     movw t2, s0
                     and  s0, s2
                     and  s1, s3
                     
                     movw t4, s6
                     eor  s6, s4
                     eor  s7, s5
                     
                     eor  s0, s6
                     eor  s1, s7
                     
                     or   s2, t4
                     or   s3, t5
                     eor  s2, t2
                     eor  s3, t3
                     
                     movw t2, s2
                     eor  s2, s4
                     eor  s3, s5
                     
                     eor  s4, t0
                     eor  s5, t1
                     and  s6, t2
                     and  s7, t3
                     eor  s6, s4
                     eor  s7, s5
                     
                     or   s4, s0
                     or   s5, s1
                     eor  s4, t2
                     eor  s5, t3
                 	pop rcnt
                 .ENDMACRO
                 
                 ;;;****************************************************************************
                 ;;;
                 ;;; substitute inverse sbox
                 ;input/output state s1:s0: a
                 ;input/output state s3:s2: b
                 ;input/output state s5:s4: c
                 ;input/output state s7:s6: d
                 
                 ; temporary register t1:t0
                 ; temporary register t3:t2
                 ; temporary register t5:t4
                 
                 .MACRO invert_sbox
                     push rcnt
                     movw t0, s0
                     and  s0, s4
                     and  s1, s5
                     
                     movw t2, s6
                     or   s6, t0
                     or   s7, t1
                     
                     eor  s4, s6
                     eor  s5, s7
                     movw s6, s4
                     
                     eor  s4, s2
                     eor  s5, s3
                     
                 	movw s2, s4
                     eor  s2, t0
                     eor  s3, t1
                     
                     eor  t2, s0
                     eor  t3, s1
                     
                     eor  s2, t2
                     eor  s3, t3
                 	
                 	com  s6
                 	com  s7
                 	
                     movw s0, t2
                     and  s0, s2
                     and  s1, s3
                 	
                 	eor  s0, s6
                     eor  s1, s7
                 	
                     or   s6, s2
                     or   s7, s3
                 	
                     eor  s6, t2
                     eor  s7, t3
                 	pop  rcnt
                 .ENDMACRO
                 
                 .MACRO rotate16_left_row1
                 	lsl s2     
                     rol s3     
                     adc s2, rzero 
                 .ENDMACRO
                 
                 .MACRO rotate16_left_row2
                     ldi t0, 0x0f
                     and t0, s4
                     andi s4, 0xf0
                     
                     ldi t1, 0x0f
                     and t1, s5
                     andi s5, 0xf0
                     
                     and s4, t1
                     swap s4
                     
                     and s5, t0
                     swap s5
                 .ENDMACRO
                 
                 .MACRO rotate16_left_row3
                 	bst s6, 0
                     ror s7   
                     ror s6    
                     bld s7, 7
                 	bst s6, 0
                     ror s7   
                     ror s6    
                     bld s7, 7
                 	bst s6, 0
                     ror s7   
                     ror s6    
                     bld s7, 7
                 .ENDMACRO
                 
                 .MACRO rotate16_right_row1
                 	bst s2, 0
                     ror s3   
                     ror s2    
                     bld s3, 7
                 .ENDMACRO
                 
                 .MACRO rotate16_right_row2
                     ldi t1, 0xf0
                     and t1, s4
                     andi s4, 0x0f
                     
                     ldi t0, 0xf0
                     and t0, s5
                     andi s5, 0x0f
                     
                     and s4, t0
                     swap s4
                     
                     and s5, t1
                     swap s5
                 .ENDMACRO
                 
                 .MACRO rotate16_right_row3
                 	lsl s6     
                     rol s7     
                     adc s6, rzero 
                 	lsl s6     
                     rol s7     
                     adc s6, rzero 
                 	lsl s6     
                     rol s7     
                     adc s6, rzero 
                 .ENDMACRO
                 
                 .MACRO forward_permutation
                     rotate16_left_row1
                     rotate16_left_row2
                     rotate16_left_row3
                 .ENDMACRO
                 
                 .MACRO invert_permutation
                     rotate16_right_row1
                     rotate16_right_row2
                     rotate16_right_row3
                 .ENDMACRO
                 
                 .MACRO keyxor
                 	eor s0, k0	
                 	eor s1, k1	
                 	eor s0, k4	
                 	eor s1, k5	
                 	eor s0, k8	
                 	eor s1, k9	
                 	eor s0, k12
                 	eor s1, k13
                 .ENDMACRO
                 
                 forward_round:
0000de 2500
0000df 2511
0000e0 2504
0000e1 2515
0000e2 2508
0000e3 2519
0000e4 250c
0000e5 251d          keyxor
0000e6 93cf
0000e7 01c9
0000e8 9520
0000e9 9530
0000ea 01d8
0000eb 2302
0000ec 2313
0000ed 01eb
0000ee 2764
0000ef 2775
0000f0 2706
0000f1 2717
0000f2 2b2c
0000f3 2b3d
0000f4 272a
0000f5 273b
0000f6 01d9
0000f7 2724
0000f8 2735
0000f9 2748
0000fa 2759
0000fb 236a
0000fc 237b
0000fd 2764
0000fe 2775
0000ff 2b40
000100 2b51
000101 274a
000102 275b
000103 91cf          forward_sbox
000104 27dd          clr rzero
000105 0f22
000106 1f33
000107 1f2d
000108 e08f
000109 2384
00010a 7f40
00010b e09f
00010c 2395
00010d 7f50
00010e 2349
00010f 9542
000110 2358
000111 9552
000112 fb60
000113 9577
000114 9567
000115 f977
000116 fb60
000117 9577
000118 9567
000119 f977
00011a fb60
00011b 9577
00011c 9567
00011d f977          forward_permutation
00011e dee9          rcall forward_key_update
00011f 95c3      	inc rcnt
000120 9508      	ret
                 
                 .MACRO forward_last_round
                     keyxor
                 .ENDMACRO
                 
                 invert_round:
000121 2500
000122 2511
000123 2504
000124 2515
000125 2508
000126 2519
000127 250c
000128 251d          keyxor
000129 93cf
00012a 01c8
00012b 2304
00012c 2315
00012d 01db
00012e 2b68
00012f 2b79
000130 2746
000131 2757
000132 01ba
000133 2742
000134 2753
000135 019a
000136 2728
000137 2739
000138 27a0
000139 27b1
00013a 272a
00013b 273b
00013c 9560
00013d 9570
00013e 018d
00013f 2302
000140 2313
000141 2706
000142 2717
000143 2b62
000144 2b73
000145 276a
000146 277b
000147 91cf          invert_sbox
000148 27dd          clr rzero
000149 fb20
00014a 9537
00014b 9527
00014c f937
00014d ef90
00014e 2394
00014f 704f
000150 ef80
000151 2385
000152 705f
000153 2348
000154 9542
000155 2359
000156 9552
000157 0f66
000158 1f77
000159 1f6d
00015a 0f66
00015b 1f77
00015c 1f6d
00015d 0f66
00015e 1f77
00015f 1f6d          invert_permutation
000160 df12          rcall invert_key_update
000161 95ca      	dec rcnt
000162 9508      	ret
                 
                 .MACRO invert_last_round
                     keyxor
                 .ENDMACRO
                 
                 encrypt:
000163 e0f0          ldi ZH, high(SRAM_KEY)
000164 e6e8          ldi ZL, low(SRAM_KEY)
000165 9001
000166 9011
000167 9021
000168 9031
000169 9041
00016a 9051
00016b 9061
00016c 9071
00016d 9081
00016e 9091
00016f 90a1
000170 90b1
000171 90c1
000172 90d1
000173 90e1
000174 80f0          load_key
000175 e0f0          ldi ZH, high(SRAM_PTEXT)
000176 e6e0          ldi ZL, low(SRAM_PTEXT)
000177 9101
000178 9111
000179 9121
00017a 9131
00017b 9141
00017c 9151
00017d 9161
00017e 8170          load_input
00017f 27cc      	clr rcnt
                 encrypt_start:
000180 df5d          rcall forward_round
000181 df5c          rcall forward_round
000182 df5b          rcall forward_round
000183 df5a          rcall forward_round
000184 df59          rcall forward_round
                 
000185 df58          rcall forward_round
000186 df57          rcall forward_round
000187 df56          rcall forward_round
000188 df55          rcall forward_round
000189 df54          rcall forward_round
                 
00018a df53          rcall forward_round
00018b df52          rcall forward_round
00018c df51          rcall forward_round
00018d df50          rcall forward_round
00018e df4f          rcall forward_round
                 
00018f df4e          rcall forward_round
000190 df4d          rcall forward_round
000191 df4c          rcall forward_round
000192 df4b          rcall forward_round
000193 df4a          rcall forward_round
                 
000194 df49          rcall forward_round
000195 df48          rcall forward_round
000196 df47          rcall forward_round
000197 df46          rcall forward_round
000198 df45          rcall forward_round
                 
000199 2500
00019a 2511
00019b 2504
00019c 2515
00019d 2508
00019e 2519
00019f 250c
0001a0 251d          forward_last_round
0001a1 e0f0          ldi ZH, high(SRAM_PTEXT)
0001a2 e6e0          ldi ZL, low(SRAM_PTEXT)
0001a3 9301
0001a4 9311
0001a5 9321
0001a6 9331
0001a7 9341
0001a8 9351
0001a9 9361
0001aa 8370          store_output
0001ab 9508      ret
                 
                 decrypt:
0001ac e0f0          ldi ZH, high(SRAM_KEY)
0001ad e6e8          ldi ZL, low(SRAM_KEY)
0001ae 9001
0001af 9011
0001b0 9021
0001b1 9031
0001b2 9041
0001b3 9051
0001b4 9061
0001b5 9071
0001b6 9081
0001b7 9091
0001b8 90a1
0001b9 90b1
0001ba 90c1
0001bb 90d1
0001bc 90e1
0001bd 80f0          load_key
0001be e0f0          ldi ZH, high(SRAM_PTEXT)
0001bf e6e0          ldi ZL, low(SRAM_PTEXT)
0001c0 9101
0001c1 9111
0001c2 9121
0001c3 9131
0001c4 9141
0001c5 9151
0001c6 9161
0001c7 8170          load_input
0001c8 e1c8      	ldi rcnt, 24
                 decrypt_start:
0001c9 df57          rcall invert_round
0001ca df56          rcall invert_round
0001cb df55          rcall invert_round
0001cc df54          rcall invert_round
0001cd df53          rcall invert_round
                 
0001ce df52          rcall invert_round
0001cf df51          rcall invert_round
0001d0 df50          rcall invert_round
0001d1 df4f          rcall invert_round
0001d2 df4e          rcall invert_round
                 
0001d3 df4d          rcall invert_round
0001d4 df4c          rcall invert_round
0001d5 df4b          rcall invert_round
0001d6 df4a          rcall invert_round
0001d7 df49          rcall invert_round
                 
0001d8 df48          rcall invert_round
0001d9 df47          rcall invert_round
0001da df46          rcall invert_round
0001db df45          rcall invert_round
0001dc df44          rcall invert_round
                 
0001dd df43          rcall invert_round
0001de df42          rcall invert_round
0001df df41          rcall invert_round
0001e0 df40          rcall invert_round
0001e1 df3f          rcall invert_round
                 
0001e2 2500
0001e3 2511
0001e4 2504
0001e5 2515
0001e6 2508
0001e7 2519
0001e8 250c
0001e9 251d          invert_last_round
0001ea e0f0          ldi ZH, high(SRAM_PTEXT)
0001eb e6e0          ldi ZL, low(SRAM_PTEXT)
0001ec 9301
0001ed 9311
0001ee 9321
0001ef 9331
0001f0 9341
0001f1 9351
0001f2 9361
0001f3 8370          store_output
0001f4 9508      ret
                 
                 
                 Sbox:
0001f5 0506
0001f6 0a0c
0001f7 0e01
0001f8 0907
0001f9 000b
0001fa 0d03
0001fb 0f08
0001fc 0204      .DB 0x6, 0x5, 0xc, 0xa, 0x1, 0xe, 0x7, 0x9, 0xb, 0x0, 0x3, 0xd, 0x8, 0xf, 0x4, 0x2
                 
                 ISbox:
0001fd 0409
0001fe 0a0f
0001ff 010e
000200 0600
000201 070c
000202 0803
000203 0b02
000204 0d05      .DB 0x9, 0x4, 0xf, 0xa, 0xe, 0x1, 0x0, 0x6, 0xc, 0x7, 0x3, 0x8, 0x2, 0xb, 0x5, 0xd
                 
                 RC:
000205 0201
000206 0904
000207 0512
000208 160b
000209 190c
00020a 0713
00020b 1f0f
00020c 1c1e
00020d 1118
00020e 0603
00020f 1b0d
000210 0e17
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm(812): warning: .cseg .db misalignment - padding zero byte
F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\interface.asm(50): 'F:\My Documents\1. Research\Design\Implementation\AVR asm tutorial\Rectangle_AVR\Rectangle_AVR\AssemblerApplication1\AssemblerApplication1\./Rectangle128OnTheFly.asm' included form here
000211 001d      .DB 0x01, 0x02, 0x04, 0x09, 0x12, 0x05, 0x0b, 0x16, 0x0c, 0x19, 0x13, 0x07, 0x0f, 0x1f, 0x1e, 0x1c, 0x18, 0x11, 0x03, 0x06, 0x0d, 0x1b, 0x17, 0x0e, 0x1d 
                 #elif desxl
                 #elif hight
                 #elif idea
                 #elif kasumi
                 #elif katan
                 #elif klein
                 #elif mcrypton
                 #elif noekeon
                 #elif present
                 #elif sea
                 #elif tea
                 #else
                 #endif
                 
                 
                 .CSEG
                 
                 ;******************** FUNCTIONS ***********************************
                 ; This function copy bytes from ROM location pointed by ZH:ZL to
                 ; SRAM location pointed by XH:XL
                 ;	Z must contain source address
                 ;	X must contain destination address
                 ;	r18 must contain the number of byte to copy
                 ;	r16 is used for internal computation
                 copy_word:
000212 9105      	lpm		r16, Z+
000213 930d      	st 		X+,r16
000214 952a      	dec		r18
000215 f7e1      	brbc	1, copy_word
000216 9508      	ret
                 ;*******************************************************************
                 
                 ;******************** Q ELEC FUNCTIONS (START) *********************
                 ; wait : ret + 0xFF * (5*nop + 1*dec + 1*brbc)
                 wait:
000217 ef0f      	ldi		r16, 0xFF	;r16=FF
                 w_loop:
000218 0000      	nop
000219 0000      	nop
00021a 0000      	nop
00021b 0000      	nop
00021c 0000      	nop
00021d 950a      	dec		r16			; r16=r16-1
00021e f7c9      	brbc	1,w_loop	; branch sur loop si Z=0, cs si r16 != 0
00021f 9508      	ret					; return from subroutine
                 
                 
                 
                 ; wait2 : r17 * wait (to be set inside) + some instructions
                 wait2:
000220 ef1f      	ldi		r17, 0xFF	;
                 w_loop2:
000221 dff5      	rcall	wait
000222 951a      	dec		r17			; r17=r17-1
000223 f7e9      	brbc	1,w_loop2	; branch sur loop2 si Z=0, cs si r17 != 0
000224 9508      	ret					; return from subroutine
                 ;******************** Q ELEC FUNCTIONS (END) *********************
                 
                 
                 ;******************** MAIN (START) *******************************
                 main:
                 	;LOAD THE PTEXT FROM THE DB BELOW TO SRAM
000225 e0f4      	ldi		ZH, high(text<<1)
000226 ebec      	ldi		ZL, low(text<<1)
000227 e0b0      	ldi 	XH, high(SRAM_PTEXT)
000228 e6a0      	ldi 	XL, low(SRAM_PTEXT)
000229 e028      	ldi		r18, PTEXT_NUM_BYTE
00022a dfe7      	rcall	copy_word
                 
                 main_loop:
                 
                 	;LOAD THE KEY FROM THE DB BELOW TO SRAM
00022b e0f4      	ldi		ZH, high(key<<1)
00022c ece4      	ldi		ZL, low(key<<1)
00022d e0b0      	ldi 	XH, high(SRAM_KEY)
00022e e6a8      	ldi 	XL, low(SRAM_KEY)
00022f e120      	ldi		r18, KEY_NUM_BYTE
000230 dfe1      	rcall	copy_word
                 
                 
                 	; Initialize XH:XL with start address of ptext/key memory location
000231 e0b0      	ldi 	XH, high(SRAM_PTEXT)
000232 e6a0      	ldi 	XL, low(SRAM_PTEXT)
000233 9ac1      	sbi		PORTB,1		; portA,0 = high (trigger on port A0)
000234 0000      	nop
000235 0000      	nop
000236 0000      	nop
000237 0000      	nop
000238 98c1       	cbi		PORTB,1		; portA,0 = low
                 
000239 0000      	nop
00023a 0000      	nop
00023b 0000      	nop
00023c 0000      	nop
00023d 0000      	nop
00023e 0000      	nop
00023f 0000      	nop
000240 0000      	nop
000241 0000      	nop
000242 0000      	nop
                 
000243 df1f      	rcall	encrypt		; encryption routine
                 
                 	;LOAD THE KEY FROM THE DB BELOW TO SRAM
000244 e0f4      	ldi		ZH, high(key<<1)
000245 ece4      	ldi		ZL, low(key<<1)
000246 e0b0      	ldi 	XH, high(SRAM_KEY)
000247 e6a8      	ldi 	XL, low(SRAM_KEY)
000248 e120      	ldi		r18, KEY_NUM_BYTE
000249 dfc8      	rcall	copy_word
                 
00024a df61      	rcall   decrypt      ; encryption routine
                 
00024b 0000      	nop
00024c 0000      	nop
00024d 0000      	nop
00024e 0000      	nop
00024f 0000      	nop
000250 0000      	nop
000251 0000      	nop
000252 0000      	nop
000253 0000      	nop
000254 0000      	nop
                 
000255 9ac0      	sbi		PORTB,0		; portA,0 = high (trigger on port A0)
000256 0000      	nop
000257 0000      	nop
000258 0000      	nop
000259 0000      	nop
00025a 98c0       	cbi		PORTB,0		; portA,0 = low
                 
                 
                 	;make a pause
00025b dfc4      	rcall	wait2
00025c dfc3      	rcall	wait2
                 ;	rcall	wait2
                 ;	rcall	wait2
                 ;	rcall	wait2
                 
                 	;encrypt again, with the cipher as the new plain
00025d cfcd      	rjmp	main_loop
                 
                 
                 
                 
                 
                 
                 	;to decrypt:
                 	;ldi 	XH, high(SRAM_DATA)
                 	;ldi 	XL, low(SRAM_DATA)
                 	;rcall decrypt		; call decryption routine
                 
                 	;rjmp	main	;let's have fun one more time
                 
                 ;text:
                 ;.db $32,$43,$f6,$a8,$88,$5a,$30,$8d,$31,$31,$98,$a2,$e0,$37,$07,$34
                 ;key:
                 ;.db $2b,$7e,$15,$16,$28,$ae,$d2,$a6,$ab,$f7,$15,$88,$09,$cf,$4f,$3c,$51,$a4,$6b,$8d,$31,$1f,$f4,$37
                 
                 text:
00025e ffff
00025f ffff
000260 ffff
000261 ffff      .db $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
                 key:
000262 0000
000263 0000
000264 0000
000265 0000
000266 0000      .db $00,$00,$00,$00,$00,$00,$00,$00,$00,$00
                 
                 ;text:
                 ;.db $f3,$44,$81,$ec,$3c,$c6,$27,$ba,$cd,$5d,$c3,$fb,$08,$f2,$73,$e6
                 ;.db $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
                 ;.db $32,$43,$f6,$a8,$88,$5a,$30,$8d,$31,$31,$98,$a2,$e0,$37,$07,$34
                 ;.db $20,$3e,$be,$9b,$b6,$fa,$fb,$eb,$65,$bc,$88,$23,$64,$0e,$02,$80
                 ;key:
                 ;.db $2b,$7e,$15,$16,$28,$ae,$d2,$a6,$ab,$f7,$15,$88,$09,$cf,$4f,$3c
                 ;.db $ff,$c0,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
                 ;.db $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
                 ;.db $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
                 ;.db $8b,$74,$f5,$8e,$9f,$49,$5e,$8f,$0a,$02,$ae,$bc,$d1,$63,$cd,$28
                 
                 .DSEG
000060             SRAM_PTEXT: .BYTE PTEXT_NUM_BYTE
000068             SRAM_KEY: .BYTE KEY_NUM_BYTE
                 ;******************** MAIN (END) *********************************
                 
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny45" register use summary:
r0 :  27 r1 :  14 r2 :  10 r3 :  10 r4 :  25 r5 :  10 r6 :  10 r7 :   6 
r8 :  25 r9 :  10 r10:  10 r11:   6 r12:  25 r13:  14 r14:  10 r15:  10 
r16:  36 r17:  29 r18:  25 r19:  17 r20:  23 r21:  21 r22:  29 r23:  23 
r24:  67 r25:  33 r26:  14 r27:  10 r28:  12 r29:  17 r30:  21 r31:  19 
x  :   1 y  :   0 z  :  71 
Registers used: 34 out of 35 (97.1%)

"ATtiny45" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  12 add   :   6 adiw  :   0 and   :  16 
andi  :   4 asr   :   0 bclr  :   0 bld   :   4 brbc  :   3 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :   0 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :   0 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   4 cbi   :   2 cbr   :   0 clc   :   0 
clh   :   0 cli   :   1 cln   :   0 clr   :   5 cls   :   0 clt   :   0 
clv   :   0 clz   :   0 com   :   4 cp    :   0 cpc   :   0 cpi   :   0 
cpse  :   0 dec   :   4 eor   :  66 icall :   0 ijmp  :   0 in    :   0 
inc   :   1 ld    :  48 ldd   :   0 ldi   :  51 lds   :   0 lpm   :  13 
lsl   :  12 lsr   :   8 mov   :  24 movw  :  21 neg   :   0 nop   :  33 
or    :   8 ori   :   0 out   :   3 pop   :   2 push  :   2 rcall :  60 
ret   :   9 reti  :   0 rjmp  :   2 rol   :  60 ror   :  72 sbc   :   0 
sbci  :   0 sbi   :   2 sbic  :   0 sbis  :   0 sbiw  :   0 sbr   :   0 
sbrc  :   0 sbrs  :   0 sec   :   0 seh   :   0 sei   :   0 sen   :   0 
ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 
spm   :   0 st    :  17 std   :   0 sts   :   0 sub   :   0 subi  :   0 
swap  :   4 tst   :   0 wdr   :   0 
Instructions used: 34 out of 105 (32.4%)

"ATtiny45" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0004ce   1154     76   1230    4096  30.0%
[.dseg] 0x000060 0x000078      0     24     24     256   9.4%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 20 warnings
